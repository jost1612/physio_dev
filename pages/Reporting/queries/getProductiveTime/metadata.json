{
  "gitSyncId": "685e483118280a5cf36d2a8a_21e2fb32-4f6a-4dc5-b3df-3a66c2f44eb3",
  "id": "Reporting_getProductiveTime",
  "pluginId": "postgres-plugin",
  "pluginType": "DB",
  "unpublishedAction": {
    "actionConfiguration": {
      "body": "/*\n * Dieses Skript analysiert die Tabelle 'schedule', um die Anzahl der verfügbaren\n * 30-Minuten-Blöcke für jeden Mitarbeiter zu ermitteln, gruppiert nach Wochentag.\n *\n * **FINALE KORREKTUR**: Die Abfrage verwendet nun AUSSCHLIESSLICH die Spalte\n * `day_abbrev` zur Gruppierung der Tage und ignoriert die Spalte `day` vollständig,\n * wie vom Benutzer gefordert.\n *\n * WICHTIGER HINWEIS: Diese Abfrage geht davon aus, dass die zu analysierenden\n * Daten aus einer einzigen Woche stammen. Wenn Daten aus mehreren Wochen vorhanden sind,\n * kann die Berechnung der Lücke zwischen den Wochen (z.B. von Freitag zu Montag)\n * zu falschen Ergebnissen führen, da nur nach dem Wochentag-Kürzel ('MO', 'DI', etc.)\n * gruppiert wird.\n */\nWITH employee_gaps AS (\n  -- Schritt 1: Finde für jeden Termin den Start des nächsten Termins am selben Wochentag.\n  SELECT\n    employee_id,\n    day_abbrev,\n    end_time,\n    LEAD(start_time, 1) OVER (\n      PARTITION BY\n        employee_id,\n        day_abbrev -- Partitionierung erfolgt jetzt nur noch nach Mitarbeiter und Wochentag-Kürzel.\n      ORDER BY\n        start_time\n    ) AS next_start_time\n  FROM\n    public.schedule\n  WHERE\n    employee_id IS NOT NULL OR\n\temployee_id <> 53\n), gap_durations AS (\n  -- Schritt 2: Berechne die Dauer der Lücke zwischen den Terminen.\n  SELECT\n    employee_id,\n    day_abbrev,\n    (next_start_time - end_time) AS gap_interval\n  FROM\n    employee_gaps\n  WHERE\n    next_start_time IS NOT NULL\n    AND next_start_time > end_time\n), calculated_slots AS (\n  -- Schritt 3: Berechne, wie viele volle 30-Minuten-Blöcke in die Lücke passen.\n  SELECT\n    employee_id,\n    day_abbrev,\n    -- Teilt die Gesamtdauer der Lücke in Sekunden durch 1800 (30 Min * 60 Sek).\n    FLOOR(EXTRACT(EPOCH FROM gap_interval) / 1800) AS num_available_slots\n  FROM\n    gap_durations\n  WHERE\n    gap_interval >= '30 minutes' :: interval -- Die Lücke muss mindestens 30 Minuten groß sein.\n)\n-- Schritt 4: Summiere die verfügbaren Blöcke pro Mitarbeiter und Wochentag.\nSELECT\n  e.name AS employee_name,\n  CASE s.day_abbrev\n      WHEN 'MO' THEN 'Montag'\n      WHEN 'DI' THEN 'Dienstag'\n      WHEN 'MI' THEN 'Mittwoch'\n      WHEN 'DO' THEN 'Donnerstag'\n      WHEN 'FR' THEN 'Freitag'\n      WHEN 'SA' THEN 'Samstag'\n      WHEN 'SO' THEN 'Sonntag'\n      ELSE s.day_abbrev\n  END AS weekday,\n  SUM(s.num_available_slots) :: BIGINT AS total_free_30min_slots\nFROM\n  calculated_slots s\n  INNER JOIN public.employees e ON s.employee_id = e.id\nWHERE\n  s.num_available_slots > 0 AND day_abbrev = {{SelectDay.selectedOptionValue}}\nGROUP BY\n  e.name,\n  s.day_abbrev\nORDER BY\n  employee_name,\n  CASE s.day_abbrev\n      WHEN 'MO' THEN 1\n      WHEN 'DI' THEN 2\n      WHEN 'MI' THEN 3\n      WHEN 'DO' THEN 4\n      WHEN 'FR' THEN 5\n      WHEN 'SA' THEN 6\n      WHEN 'SO' THEN 7\n  END;\n",
      "encodeParamsToggle": true,
      "paginationType": "NONE",
      "pluginSpecifiedTemplates": [
        {
          "value": true
        }
      ],
      "timeoutInMillisecond": 10000
    },
    "confirmBeforeExecute": false,
    "datasource": {
      "id": "PhysioPlanung_DEV",
      "isAutoGenerated": false,
      "name": "PhysioPlanung_DEV",
      "pluginId": "postgres-plugin"
    },
    "dynamicBindingPathList": [
      {
        "key": "body"
      }
    ],
    "name": "getProductiveTime",
    "pageId": "Reporting",
    "runBehaviour": "ON_PAGE_LOAD",
    "userSetOnLoad": false
  }
}