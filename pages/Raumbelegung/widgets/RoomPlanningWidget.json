{
  "backgroundColor": "#FFFFFF",
  "borderColor": "#E0DEDE",
  "borderRadius": "{{appsmith.theme.borderRadius.appBorderRadius}}",
  "borderWidth": "1",
  "bottomRow": 213,
  "boxShadow": "{{appsmith.theme.boxShadow.appBoxShadow}}",
  "defaultModel": "{{{\n  selectedRoom: selectRoom.selectedOptionValue,\n  selectedRoomName: selectRoom.selectedOptionLabel,\n  initialData: getRoomSchedules.data,\n  tasks: getTasks.data,\n  employees: getEmployeesForRooms.data\n}}}",
  "dynamicBindingPathList": [
    {
      "key": "theme"
    },
    {
      "key": "borderRadius"
    },
    {
      "key": "boxShadow"
    },
    {
      "key": "defaultModel"
    }
  ],
  "dynamicHeight": "FIXED",
  "dynamicPropertyPathList": [
    {
      "key": "onDeleteSingle"
    },
    {
      "key": "onDeleteAllRoom"
    },
    {
      "key": "onCheckAvailability"
    }
  ],
  "dynamicTriggerPathList": [
    {
      "key": "onOpenExportModal"
    },
    {
      "key": "onSaveRoom"
    },
    {
      "key": "onCheckAvailability"
    },
    {
      "key": "onDeleteSingle"
    },
    {
      "key": "onDeleteAllRoom"
    }
  ],
  "events": [
    "onOpenExportModal",
    "onCheckAvailability",
    "onSaveRoom",
    "onDeleteSingle",
    "onDeleteAllRoom"
  ],
  "isCanvas": false,
  "isLoading": false,
  "isSearchWildcard": true,
  "isVisible": true,
  "key": "znf4t3z8kg",
  "leftColumn": 0,
  "maxDynamicHeight": 9000,
  "minDynamicHeight": 4,
  "mobileBottomRow": 39,
  "mobileLeftColumn": 0,
  "mobileRightColumn": 23,
  "mobileTopRow": 9,
  "needsErrorInfo": false,
  "onCheckAvailability": "{{onCheckAvailability.checkAvailability();}}",
  "onDeleteAllRoom": "{{onDeleteAllRoom.deleteAllRoomSchedules()}}",
  "onDeleteSingle": "{{onDeleteSingle.deleteRoomSchedule()}}",
  "onOpenExportModal": "{{navigateTo('Excel Export Räume', {\n  Room: selectRoom.selectedOptionValue\n}, 'SAME_WINDOW');}}",
  "onSaveRoom": "{{onSaveRoom.saveRoom()}}",
  "originalBottomRow": 118,
  "originalTopRow": 9,
  "parentColumnSpace": 16.1875,
  "parentId": "0",
  "parentRowSpace": 10,
  "renderMode": "CANVAS",
  "rightColumn": 63,
  "srcDoc": {
    "css": "@charset \"UTF-8\";\n/* ─── Appsmith-konforme Schriftart ─── */\n* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n  font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;\n}\n\n/* ─── Container ─── */\n.widget-container {\n  padding: 16px;\n  background: #fafafa;\n  border-radius: 4px;\n  font-size: 14px;\n  color: #212529;\n}\n\n/* ─── Unsaved Changes Warning ─── */\n.unsaved-warning {\n  background: linear-gradient(135deg, #FF4757, #FF6348);\n  color: white;\n  padding: 12px 16px;\n  border-radius: 8px;\n  margin-bottom: 16px;\n  display: flex;\n  align-items: center;\n  gap: 10px;\n  font-weight: 600;\n  box-shadow: 0 4px 12px rgba(255, 71, 87, 0.3);\n  animation: pulse-warning 2s infinite;\n}\n\n@keyframes pulse-warning {\n  0%, 100% {\n    opacity: 1;\n  }\n  50% {\n    opacity: 0.8;\n  }\n}\n/* ─── Room Header Section ─── */\n.room-header {\n  background: linear-gradient(135deg, #17a2b8, #138496);\n  color: white;\n  padding: 15px;\n  border-radius: 8px;\n  margin-bottom: 20px;\n  box-shadow: 0 4px 15px rgba(23, 162, 184, 0.3);\n}\n\n.room-header h3 {\n  margin: 0 0 8px 0;\n  display: flex;\n  align-items: center;\n  gap: 8px;\n  font-size: 16px;\n  font-weight: 600;\n}\n\n.room-info {\n  font-size: 14px;\n  margin-bottom: 4px;\n}\n\n.room-details {\n  font-size: 12px;\n  opacity: 0.9;\n  margin-top: 4px;\n}\n\n/* ─── Debug Panel ─── */\n.debug-panel {\n  margin-bottom: 15px;\n  padding: 12px;\n  background: linear-gradient(135deg, #f8f9fa, #e9ecef);\n  border: 1px solid #dee2e6;\n  border-radius: 8px;\n  font-size: 12px;\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n}\n\n.debug-title {\n  font-weight: 600;\n  margin-bottom: 8px;\n  color: #495057;\n  display: flex;\n  align-items: center;\n  gap: 6px;\n}\n\n.debug-log-item {\n  margin: 3px 0;\n  color: #495057;\n  padding: 2px 0;\n  border-bottom: 1px solid rgba(222, 226, 230, 0.5);\n}\n\n.debug-clear-btn {\n  margin-top: 8px;\n  padding: 4px 8px;\n  font-size: 11px;\n  border: 1px solid #dee2e6;\n  background: white;\n  border-radius: 4px;\n  cursor: pointer;\n  transition: all 0.2s ease;\n}\n\n.debug-clear-btn:hover {\n  background: #f8f9fa;\n  transform: translateY(-1px);\n}\n\n/* ─── Modern Button Row ─── */\n.button-row {\n  display: flex;\n  gap: 12px;\n  margin-bottom: 20px;\n  flex-wrap: wrap;\n}\n\n.modern-btn {\n  display: flex;\n  align-items: center;\n  gap: 8px;\n  padding: 12px 20px;\n  border: none;\n  border-radius: 8px;\n  font-size: 14px;\n  font-weight: 600;\n  cursor: pointer;\n  transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);\n  text-decoration: none;\n  min-height: 44px;\n  position: relative;\n  overflow: hidden;\n}\n\n.modern-btn::before {\n  content: \"\";\n  position: absolute;\n  top: 0;\n  left: -100%;\n  width: 100%;\n  height: 100%;\n  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);\n  transition: left 0.5s;\n}\n\n.modern-btn:hover::before {\n  left: 100%;\n}\n\n.btn-reset {\n  background: linear-gradient(135deg, #667eea, #764ba2);\n  color: white;\n  box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);\n}\n\n.btn-reset:hover {\n  transform: translateY(-2px);\n  box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);\n}\n\n.btn-delete-all {\n  background: linear-gradient(135deg, #ff6b6b, #ee5a52);\n  color: white;\n  box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);\n}\n\n.btn-delete-all:hover {\n  transform: translateY(-2px);\n  box-shadow: 0 8px 25px rgba(255, 107, 107, 0.4);\n}\n\n.btn-save {\n  background: linear-gradient(135deg, #51cf66, #40c057);\n  color: white;\n  box-shadow: 0 4px 15px rgba(81, 207, 102, 0.3);\n}\n\n.btn-save:hover {\n  transform: translateY(-2px);\n  box-shadow: 0 8px 25px rgba(81, 207, 102, 0.4);\n}\n\n.btn-export {\n  background: linear-gradient(135deg, #339af0, #228be6);\n  color: white;\n  box-shadow: 0 4px 15px rgba(51, 154, 240, 0.3);\n}\n\n.btn-export:hover {\n  transform: translateY(-2px);\n  box-shadow: 0 8px 25px rgba(51, 154, 240, 0.4);\n}\n\n/* ─── Modern Grid Table ─── */\n.grid-table {\n  width: 100%;\n  border-collapse: separate;\n  border-spacing: 0;\n  background: white;\n  border-radius: 12px;\n  overflow: hidden;\n  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);\n  border: 1px solid #e9ecef;\n  table-layout: fixed;\n}\n\n.grid-table th {\n  background: linear-gradient(135deg, #495057, #343a40);\n  color: white;\n  padding: 16px 8px;\n  text-align: center;\n  font-weight: 700;\n  font-size: 13px;\n  text-transform: uppercase;\n  letter-spacing: 0.5px;\n  border-bottom: 3px solid #212529;\n}\n\n.grid-table th:first-child {\n  width: 80px;\n  min-width: 80px;\n}\n\n.grid-table th:not(:first-child) {\n  width: calc((100% - 80px) / 5);\n}\n\n.grid-table td {\n  padding: 6px;\n  text-align: center;\n  border: 1px solid #e9ecef;\n  background: white;\n  position: relative;\n  min-height: 36px;\n  transition: all 0.15s ease;\n}\n\n.grid-table td:hover {\n  background: #f8f9fa !important;\n  transform: scale(1.02);\n  z-index: 10;\n}\n\n.time-cell {\n  background: #f8f9fa !important;\n  font-weight: 600;\n  color: #495057;\n  width: 80px;\n  font-size: 12px;\n  border-right: 2px solid #dee2e6;\n}\n\n.task-cell {\n  cursor: move;\n  border-radius: 6px;\n  padding: 10px;\n  font-weight: 600;\n  font-size: 13px;\n  position: relative;\n  overflow: hidden;\n  border: 2px solid rgba(255, 255, 255, 0.8) !important;\n}\n\n.task-cell::before {\n  content: \"\";\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background: linear-gradient(135deg, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.1));\n  pointer-events: none;\n}\n\n.task-cell:hover {\n  transform: translateY(-2px) scale(1.02);\n  box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);\n}\n\n/* ─── Searchable Dropdown ─── */\n.search-dropdown {\n  position: relative;\n  width: 100%;\n  z-index: 9999;\n}\n\n.search-input {\n  width: 100%;\n  padding: 10px 12px;\n  border: 2px solid #e9ecef;\n  border-radius: 8px;\n  font-size: 13px;\n  font-weight: 500;\n  outline: none;\n  transition: all 0.2s ease;\n  background: white;\n  min-height: 36px;\n}\n\n.search-input:focus {\n  border-color: #17a2b8;\n  box-shadow: 0 0 0 3px rgba(23, 162, 184, 0.15);\n  background: #fff;\n}\n\n.search-input:disabled {\n  background: #fff3cd;\n  border-color: #ffc107;\n  cursor: wait;\n}\n\n/* ─── Dropdown List ─── */\n.dropdown-list {\n  position: fixed;\n  background: white;\n  border: 2px solid #e9ecef;\n  border-radius: 8px;\n  max-height: 450px;\n  overflow-y: auto;\n  z-index: 99999;\n  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.25);\n  min-width: 350px;\n  animation: dropdownSlideDown 0.15s ease-out;\n}\n\n/* ─── Standard Dropdown in Zellen ─── */\n.search-dropdown .dropdown-list:not([style*=\"position: fixed\"]) {\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 100%;\n  margin-top: 2px;\n  z-index: 1000;\n}\n\n@keyframes dropdownSlideDown {\n  from {\n    opacity: 0;\n    transform: translateY(-8px) scale(0.98);\n  }\n  to {\n    opacity: 1;\n    transform: translateY(0) scale(1);\n  }\n}\n.dropdown-header {\n  padding: 12px 16px;\n  background: linear-gradient(135deg, #17a2b8, #138496);\n  color: white;\n  font-weight: 600;\n  font-size: 13px;\n  display: flex;\n  align-items: center;\n  gap: 6px;\n}\n\n.dropdown-loading {\n  padding: 15px 12px;\n  text-align: center;\n  background: #fff3cd;\n  border-bottom: 1px solid #dee2e6;\n  color: #856404;\n  font-size: 13px;\n  font-weight: 600;\n}\n\n.dropdown-item {\n  padding: 12px 16px;\n  cursor: pointer;\n  border-bottom: 1px solid #f8f9fa;\n  display: flex;\n  align-items: center;\n  gap: 10px;\n  font-size: 13px;\n  font-weight: 500;\n  transition: all 0.1s ease;\n}\n\n.dropdown-item:hover {\n  background: #f8f9fa;\n  transform: translateX(4px);\n}\n\n.dropdown-item:last-child {\n  border-bottom: none;\n}\n\n.dropdown-item.remove-item {\n  color: #e03131;\n  font-weight: 600;\n}\n\n.dropdown-item.remove-item:hover {\n  background: #fff5f5;\n}\n\n.employee-select-section {\n  padding: 12px;\n  border-bottom: 2px solid #e9ecef;\n  background: #f8f9fa;\n}\n\n.employee-select-label {\n  font-size: 12px;\n  font-weight: 600;\n  color: #495057;\n  margin-bottom: 6px;\n  display: block;\n}\n\n.employee-select {\n  width: 100%;\n  padding: 6px 8px;\n  border: 1px solid #dee2e6;\n  border-radius: 4px;\n  font-size: 13px;\n  background: white;\n  transition: all 0.2s ease;\n}\n\n.employee-select:focus {\n  border-color: #17a2b8;\n  box-shadow: 0 0 0 2px rgba(23, 162, 184, 0.2);\n}\n\n.employee-success-msg {\n  font-size: 11px;\n  color: #28a745;\n  margin-top: 4px;\n  display: flex;\n  align-items: center;\n  gap: 4px;\n}\n\n.task-color-preview {\n  width: 16px;\n  height: 16px;\n  border-radius: 4px;\n  border: 2px solid rgba(255, 255, 255, 0.8);\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n\n.task-duration {\n  font-size: 11px;\n  color: #868e96;\n  margin-left: auto;\n  font-weight: 600;\n  background: #f8f9fa;\n  padding: 2px 6px;\n  border-radius: 4px;\n}\n\n/* ─── Delete Button ─── */\n.delete-icon {\n  background: rgba(255, 255, 255, 0.95);\n  border: none;\n  border-radius: 6px;\n  padding: 6px;\n  cursor: pointer;\n  margin-left: 8px;\n  transition: all 0.2s ease;\n  font-size: 14px;\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n}\n\n.delete-icon:hover {\n  background: #ff6b6b;\n  transform: scale(1.15);\n  box-shadow: 0 4px 12px rgba(255, 107, 107, 0.3);\n}\n\n/* ─── Unsaved Changes Badge ─── */\n.unsaved-badge {\n  position: absolute;\n  top: -4px;\n  right: -4px;\n  background: #ff6b6b;\n  color: white;\n  border-radius: 50%;\n  width: 12px;\n  height: 12px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-size: 8px;\n  font-weight: bold;\n  animation: pulse-badge 1.5s infinite;\n  border: 2px solid white;\n  box-shadow: 0 2px 8px rgba(255, 107, 107, 0.4);\n}\n\n@keyframes pulse-badge {\n  0%, 100% {\n    transform: scale(1);\n  }\n  50% {\n    transform: scale(1.2);\n  }\n}\n/* ─── Task Content ─── */\n.task-content {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  position: relative;\n  z-index: 10;\n}\n\n.task-name {\n  flex: 1;\n  cursor: pointer;\n  padding: 6px;\n  border-radius: 4px;\n  transition: all 0.2s ease;\n  font-weight: 600;\n}\n\n.task-name:hover {\n  background: rgba(255, 255, 255, 0.3);\n  transform: scale(1.05);\n}\n\n.task-employee-badge {\n  font-size: 11px;\n  opacity: 0.9;\n  background: rgba(255, 255, 255, 0.2);\n  padding: 2px 4px;\n  border-radius: 3px;\n  margin-top: 2px;\n  display: flex;\n  align-items: center;\n  gap: 2px;\n}\n\n/* ─── Empty Cell ─── */\n.empty-cell {\n  cursor: pointer;\n  transition: all 0.2s ease;\n  position: relative;\n}\n\n.empty-cell:hover {\n  background: #e3f2fd !important;\n}\n\n.empty-cell::after {\n  content: \"+\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  font-size: 16px;\n  color: #868e96;\n  opacity: 0;\n  transition: opacity 0.2s ease;\n}\n\n.empty-cell:hover::after {\n  opacity: 1;\n}\n\n/* ─── Mobile & Touch Optimierungen ─── */\n@media (max-width: 768px) {\n  .widget-container {\n    padding: 12px;\n  }\n  .button-row {\n    flex-direction: column;\n    gap: 8px;\n  }\n  .modern-btn {\n    justify-content: center;\n    min-height: 48px;\n    font-size: 16px;\n  }\n  .grid-table {\n    font-size: 12px;\n  }\n  .grid-table th, .grid-table td {\n    padding: 8px 4px;\n    min-height: 44px;\n  }\n  .grid-table th:first-child {\n    width: 60px;\n    min-width: 60px;\n  }\n  .grid-table th:not(:first-child) {\n    width: calc((100% - 60px) / 5);\n  }\n  .task-cell {\n    min-height: 44px;\n    padding: 8px;\n  }\n  .search-input {\n    font-size: 16px;\n    min-height: 44px;\n    padding: 12px;\n  }\n  .dropdown-item {\n    padding: 16px 12px;\n    min-height: 48px;\n    font-size: 14px;\n  }\n  .delete-icon {\n    padding: 8px;\n    min-height: 44px;\n    min-width: 44px;\n  }\n  .dropdown-list {\n    min-width: 300px;\n  }\n}\n@media (max-width: 480px) {\n  .grid-table th, .grid-table td {\n    padding: 6px 2px;\n    font-size: 11px;\n  }\n  .grid-table th:first-child {\n    width: 50px;\n    min-width: 50px;\n  }\n  .grid-table th:not(:first-child) {\n    width: calc((100% - 50px) / 5);\n  }\n  .modern-btn {\n    padding: 12px 16px;\n  }\n  .dropdown-list {\n    left: 8px !important;\n    right: 8px;\n    width: calc(100vw - 16px) !important;\n    min-width: unset !important;\n  }\n}\n/* ─── Touch-Geräte Optimierungen ─── */\n@media (hover: none) and (pointer: coarse) {\n  .task-cell:hover,\n  .grid-table td:hover,\n  .empty-cell:hover {\n    transform: none;\n    background: inherit !important;\n  }\n  .modern-btn:hover {\n    transform: none;\n  }\n  .dropdown-item:hover {\n    transform: none;\n  }\n  .task-name:hover {\n    transform: none;\n    background: rgba(255, 255, 255, 0.2);\n  }\n  .dropdown-list {\n    max-height: 60vh;\n    border-radius: 12px;\n  }\n  .dropdown-item {\n    border-bottom: 1px solid #f1f3f4;\n  }\n}\n/* ─── Scrollbar Styling ─── */\n.dropdown-list::-webkit-scrollbar {\n  width: 6px;\n}\n\n.dropdown-list::-webkit-scrollbar-track {\n  background: #f8f9fa;\n}\n\n.dropdown-list::-webkit-scrollbar-thumb {\n  background: #dee2e6;\n  border-radius: 3px;\n}\n\n.dropdown-list::-webkit-scrollbar-thumb:hover {\n  background: #adb5bd;\n}",
    "html": "<!-- no need to write html, head, body tags, it is handled by the widget -->\n<div id=\"root\"></div>\n",
    "js": "// ─── ROOM PLANNING WIDGET - MIT MASTER-DESIGN ───\n\nimport React from \"https://esm.sh/react@18.2.0\";\nimport ReactDOM from \"https://esm.sh/react-dom@18.2.0\";\nimport * as XLSX from \"https://esm.sh/xlsx@0.18.5\";\n\n// ─── ERWEITERTE FARBPALETTE - 80 EINZIGARTIGE FARBEN ───\nconst MODERN_TASK_COLORS = [\n// Rot-Familie (10 Farben)\n'#FF6B6B', '#FF4757', '#FF3838', '#FF6347', '#E74C3C', '#C0392B', '#E55039', '#FA8072', '#DC143C', '#B22222',\n// Rosa-Familie (10 Farben)\n'#FF69B4', '#FFB6C1', '#FFC0CB', '#FF1493', '#DA70D6', '#BA55D3', '#DDA0DD', '#EE82EE', '#FF20FF', '#C71585',\n// Orange-Familie (10 Farben)\n'#FFB347', '#FF7F50', '#FF8C00', '#FFA500', '#EB984E', '#D2691E', '#F39C12', '#E67E22', '#CD853F', '#FF4500',\n// Gelb-Familie (10 Farben)\n'#FFEAA7', '#F7DC6F', '#F4D03F', '#F1C40F', '#FFD700', '#FFFF99', '#F9E79F', '#FAD7A0', '#FFFACD', '#FFFFE0',\n// Grün-Familie (10 Farben)\n'#96CEB4', '#82E0AA', '#A9DFBF', '#52C41A', '#2ECC71', '#27AE60', '#98D8C8', '#40E0D0', '#00FA9A', '#32CD32',\n// Türkis-Familie (10 Farben)\n'#4ECDC4', '#A3E4D7', '#00CED1', '#1ABC9C', '#20B2AA', '#48CAE4', '#00B4D8', '#0077B6', '#023E8A', '#03045E',\n// Blau-Familie (10 Farben)\n'#45B7D1', '#85C1E9', '#AED6F1', '#3498DB', '#2980B9', '#87CEEB', '#4682B4', '#6495ED', '#4169E1', '#0000FF',\n// Lila-Familie (10 Farben)\n'#BB8FCE', '#D7BDE2', '#9B59B6', '#8E44AD', '#663399', '#9370DB', '#8A2BE2', '#7B68EE', '#6A5ACD', '#483D8B'];\n\n// ─── KONFIGURATION ───\nconst CONFIG = {\n  days: [\"Mo\", \"Di\", \"Mi\", \"Do\", \"Fr\"],\n  startHour: 7,\n  endHour: 18,\n  slotMinutes: 15,\n  maxPollingAttempts: 25,\n  pollingInterval: 200\n};\n\n// ─── HILFSFUNKTIONEN ───\nfunction getModernTaskColor(taskName) {\n  let hash = 0;\n  for (let i = 0; i < taskName.length; i++) {\n    hash = taskName.charCodeAt(i) + ((hash << 5) - hash);\n  }\n  const index = Math.abs(hash) % MODERN_TASK_COLORS.length;\n  return MODERN_TASK_COLORS[index];\n}\nfunction generateTimeSlots() {\n  const slots = [];\n  for (let h = CONFIG.startHour; h < CONFIG.endHour; h++) {\n    for (let m = 0; m < 60; m += CONFIG.slotMinutes) {\n      const hh = String(h).padStart(2, \"0\");\n      const mm = String(m).padStart(2, \"0\");\n      slots.push(`${hh}:${mm}`);\n    }\n  }\n  return slots;\n}\nfunction hasUnsavedChanges(gridState) {\n  const unsavedCells = Object.values(gridState).filter(cell => cell && cell.root && !cell.existing);\n  console.log(\"🔍 hasUnsavedChanges Debug:\");\n  console.log(\"  Alle root Zellen:\", Object.values(gridState).filter(cell => cell && cell.root));\n  console.log(\"  Ungespeicherte Zellen:\", unsavedCells);\n  console.log(\"  Ergebnis:\", unsavedCells.length > 0);\n  return unsavedCells.length > 0;\n}\nfunction calculateEndTime(startTime, durationMinutes) {\n  const [hours, minutes] = startTime.split(':').map(Number);\n  const startMinutes = hours * 60 + minutes;\n  const endMinutes = startMinutes + durationMinutes;\n  const endHours = Math.floor(endMinutes / 60);\n  const endMins = endMinutes % 60;\n  return `${String(endHours).padStart(2, '0')}:${String(endMins).padStart(2, '0')}`;\n}\n\n// ─── DROPDOWN KOMPONENTE ───\nfunction RoomPlanningDropdown({\n  tasks,\n  employees = [],\n  onSelect,\n  onCancel,\n  currentTask = null,\n  currentEmployee = null,\n  isInTableCell = false,\n  loading = false\n}) {\n  const [searchTerm, setSearchTerm] = React.useState('');\n  const [selectedEmployee, setSelectedEmployee] = React.useState(currentEmployee || '');\n  const [dropdownPosition, setDropdownPosition] = React.useState({\n    top: 0,\n    left: 0,\n    width: 200,\n    maxHeight: 450\n  });\n  const [portalContainer, setPortalContainer] = React.useState(null);\n  const inputRef = React.useRef(null);\n  const dropdownRef = React.useRef(null);\n  React.useEffect(() => {\n    if (!inputRef.current) return;\n    inputRef.current.focus();\n\n    // Portal Container erstellen\n    const container = document.createElement('div');\n    container.style.position = 'absolute';\n    container.style.top = '0';\n    container.style.left = '0';\n    container.style.zIndex = '10000';\n    document.body.appendChild(container);\n    setPortalContainer(container);\n\n    // Position berechnen\n    const rect = inputRef.current.getBoundingClientRect();\n    const viewportHeight = window.innerHeight;\n    const spaceBelow = viewportHeight - rect.bottom;\n    const maxDropdownHeight = Math.max(200, spaceBelow - 20);\n    setDropdownPosition({\n      top: rect.bottom + window.scrollY + 4,\n      left: rect.left + window.scrollX,\n      width: Math.max(rect.width, 350),\n      maxHeight: Math.min(450, maxDropdownHeight)\n    });\n\n    // Auto-scroll wenn nötig\n    setTimeout(() => {\n      const dropdownBottom = rect.bottom + Math.min(450, maxDropdownHeight);\n      if (dropdownBottom > viewportHeight) {\n        const scrollOffset = dropdownBottom - viewportHeight + 20;\n        window.scrollBy({\n          top: scrollOffset,\n          behavior: 'smooth'\n        });\n      }\n    }, 50);\n    return () => {\n      if (container && document.body.contains(container)) {\n        document.body.removeChild(container);\n      }\n    };\n  }, []);\n  const filteredTasks = tasks.filter(task => task.name.toLowerCase().includes(searchTerm.toLowerCase()));\n  const handleSelect = taskId => {\n    onSelect(taskId, selectedEmployee);\n  };\n  const handleKeyDown = e => {\n    if (e.key === 'Escape') {\n      onCancel();\n    } else if (e.key === 'Enter' && filteredTasks.length > 0) {\n      handleSelect(filteredTasks[0].id);\n    }\n  };\n  const handleBlur = e => {\n    setTimeout(() => {\n      const activeElement = document.activeElement;\n      const dropdownElement = dropdownRef.current;\n      const portalElement = portalContainer;\n      const focusInsideDropdown = dropdownElement && dropdownElement.contains(activeElement) || portalElement && portalElement.contains(activeElement) || activeElement && activeElement.closest('[data-dropdown-content]');\n      if (!focusInsideDropdown) {\n        console.log(\"🔍 Fokus verlassen - schließe Dropdown\");\n        onCancel();\n      }\n    }, 100);\n  };\n  const dropdownStyle = {\n    position: 'fixed',\n    top: `${dropdownPosition.top}px`,\n    left: `${dropdownPosition.left}px`,\n    width: `${dropdownPosition.width}px`,\n    maxHeight: `${dropdownPosition.maxHeight}px`\n  };\n  const renderDropdown = () => /*#__PURE__*/React.createElement(\"div\", {\n    ref: dropdownRef,\n    className: \"dropdown-list\",\n    style: dropdownStyle,\n    \"data-dropdown-content\": \"true\"\n  }, loading && /*#__PURE__*/React.createElement(\"div\", {\n    className: \"dropdown-loading\"\n  }, \"\\uD83D\\uDD04 Pr\\xFCfe Mitarbeiter-Verf\\xFCgbarkeit...\"), /*#__PURE__*/React.createElement(\"div\", {\n    className: \"dropdown-header\"\n  }, \"\\uD83C\\uDFE2 Raum-Planung mit Mitarbeiter-Zuweisung\"), /*#__PURE__*/React.createElement(\"div\", {\n    onClick: () => handleSelect(\"\"),\n    className: \"dropdown-item remove-item\"\n  }, \"\\uD83D\\uDDD1\\uFE0F Entfernen\"), /*#__PURE__*/React.createElement(\"div\", {\n    className: \"employee-select-section\"\n  }, /*#__PURE__*/React.createElement(\"label\", {\n    className: \"employee-select-label\"\n  }, \"\\uD83D\\uDC64 Mitarbeiter zuweisen:\"), /*#__PURE__*/React.createElement(\"select\", {\n    value: selectedEmployee,\n    onChange: e => {\n      console.log(\"🔍 Mitarbeiter geändert:\", e.target.value);\n      setSelectedEmployee(e.target.value);\n    },\n    className: \"employee-select\"\n  }, /*#__PURE__*/React.createElement(\"option\", {\n    value: \"\"\n  }, \"-- Kein Mitarbeiter --\"), employees.map(emp => /*#__PURE__*/React.createElement(\"option\", {\n    key: emp.id,\n    value: emp.id\n  }, emp.name))), selectedEmployee && /*#__PURE__*/React.createElement(\"div\", {\n    className: \"employee-success-msg\"\n  }, \"\\u2713 Verf\\xFCgbarkeitspr\\xFCfung wird durchgef\\xFChrt\")), filteredTasks.map(task => /*#__PURE__*/React.createElement(\"div\", {\n    key: task.id,\n    onClick: () => handleSelect(task.id),\n    className: \"dropdown-item\",\n    style: {\n      fontWeight: currentTask === task.name ? '600' : '500',\n      backgroundColor: currentTask === task.name ? '#f8f9fa' : 'white'\n    }\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    className: \"task-color-preview\",\n    style: {\n      backgroundColor: getModernTaskColor(task.name)\n    }\n  }), /*#__PURE__*/React.createElement(\"span\", {\n    style: {\n      flex: 1\n    }\n  }, task.name), /*#__PURE__*/React.createElement(\"span\", {\n    className: \"task-duration\"\n  }, task.duration_minutes, \"min\"))), filteredTasks.length === 0 && searchTerm && /*#__PURE__*/React.createElement(\"div\", {\n    style: {\n      padding: '10px 12px',\n      color: '#868e96',\n      fontSize: '13px',\n      fontStyle: 'italic'\n    }\n  }, \"Keine Tasks gefunden\"));\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: \"search-dropdown\"\n  }, /*#__PURE__*/React.createElement(\"input\", {\n    ref: inputRef,\n    type: \"text\",\n    className: \"search-input\",\n    placeholder: loading ? \"Prüfe Verfügbarkeit...\" : \"Task für Raum suchen...\",\n    value: searchTerm,\n    onChange: e => setSearchTerm(e.target.value),\n    onKeyDown: handleKeyDown,\n    onBlur: handleBlur,\n    disabled: loading\n  }), portalContainer && ReactDOM.createPortal(renderDropdown(), portalContainer));\n}\n\n// ─── HAUPTKOMPONENTE ───\nfunction App(props) {\n  // State\n  const roomId = appsmith.model?.selectedRoom ?? null;\n  const roomName = appsmith.model?.selectedRoomName ?? null;\n  const tasks = appsmith.model?.tasks || [];\n  const employees = appsmith.model?.employees || [];\n  const [allGridStates, setAllGridStates] = React.useState({});\n  const [activeCell, setActiveCell] = React.useState(null);\n  const [dragSource, setDragSource] = React.useState(null);\n  const [debugLog, setDebugLog] = React.useState([]);\n\n  // Debug-Funktion\n  const addDebugLog = React.useCallback(message => {\n    console.log(\"DEBUG:\", message);\n    setDebugLog(prev => [...prev.slice(-4), `${new Date().toLocaleTimeString()}: ${message}`]);\n  }, []);\n\n  // Lade Raum-Schedule\n  React.useEffect(() => {\n    if (!roomId) {\n      setAllGridStates({});\n      return;\n    }\n    const rawData = appsmith.model.initialData || [];\n    const loaded = {};\n    if (Array.isArray(rawData)) {\n      addDebugLog(`Transformiere ${rawData.length} DB-Records zu Widget-Format`);\n      rawData.forEach(record => {\n        const {\n          schedule_id,\n          day_abbrev,\n          start_time,\n          end_time,\n          task_name,\n          duration_minutes,\n          employee_id\n        } = record;\n        const startTime = start_time.slice(0, 5);\n        const key = `${day_abbrev}-${startTime}`;\n        const rowspan = Math.ceil(duration_minutes / 15);\n        loaded[key] = {\n          task: task_name,\n          taskId: record.task_id,\n          root: true,\n          rowspan: rowspan,\n          existing: true,\n          scheduleId: schedule_id,\n          assignedEmployee: employee_id,\n          duration_minutes: duration_minutes\n        };\n\n        // Fülle weitere Zellen für rowspan\n        const slots = generateTimeSlots();\n        const startIdx = slots.indexOf(startTime);\n        for (let i = 1; i < rowspan; i++) {\n          const nextTime = slots[startIdx + i];\n          if (nextTime) {\n            loaded[`${day_abbrev}-${nextTime}`] = {\n              task: task_name,\n              taskId: record.task_id,\n              root: false,\n              rowspan: rowspan,\n              existing: true,\n              scheduleId: schedule_id,\n              assignedEmployee: employee_id,\n              duration_minutes: duration_minutes\n            };\n          }\n        }\n      });\n      addDebugLog(`✓ Transformiert zu Widget-Keys: [${Object.keys(loaded).join(', ')}]`);\n    }\n    setAllGridStates(prev => {\n      const copy = {\n        ...prev\n      };\n      const currentState = copy[roomId] || {};\n      const hasUnsavedLocal = hasUnsavedChanges(currentState);\n      addDebugLog(`RaumID: ${roomId}, hasUnsavedLocal: ${hasUnsavedLocal}`);\n      if (!hasUnsavedLocal) {\n        addDebugLog(`✓ Übernehme transformierte DB-Daten für Raum ${roomId} (${Object.keys(loaded).length} Zellen)`);\n        copy[roomId] = loaded;\n        return copy;\n      }\n      addDebugLog(`⚠️ Behalte lokale Änderungen für Raum ${roomId} (${Object.keys(currentState).length} Einträge)`);\n      return prev;\n    });\n  }, [roomId, JSON.stringify(appsmith.model.initialData || []), addDebugLog]);\n  const gridState = allGridStates[roomId] || {};\n  const hasChanges = hasUnsavedChanges(gridState);\n\n  // ─── VERFÜGBARKEITSPRÜFUNG ───\n  const checkEmployeeAvailability = async (employeeId, day, time, durationMinutes) => {\n    if (!employeeId) {\n      addDebugLog(\"❌ Kein Mitarbeiter ausgewählt - überspringe Verfügbarkeitsprüfung\");\n      return {\n        available: true,\n        conflicts: []\n      };\n    }\n    addDebugLog(`🔍 Prüfe Verfügbarkeit für Mitarbeiter ${employeeId} am ${day} ${time} (${durationMinutes}min)`);\n    try {\n      const endTime = calculateEndTime(time, durationMinutes);\n      addDebugLog(`Verfügbarkeitsprüfung: ${day} ${time}-${endTime} für Mitarbeiter ${employeeId}`);\n      const requestId = `check_${employeeId}_${day}_${time}_${Date.now()}`;\n\n      // Store initialisieren\n      appsmith.store.availabilityConflicts = [];\n      appsmith.store.availabilityRequestId = null;\n\n      // Model aktualisieren\n      appsmith.updateModel({\n        checkAvailability: {\n          employeeId: parseInt(employeeId, 10),\n          dayAbbrev: day,\n          startTime: time,\n          endTime: endTime,\n          requestId: requestId\n        }\n      });\n      addDebugLog(`Model aktualisiert mit RequestID: ${requestId}`);\n\n      // Event auslösen\n      await appsmith.triggerEvent(\"onCheckAvailability\");\n      addDebugLog(\"Event ausgelöst, warte auf Ergebnis...\");\n\n      // Polling für Ergebnis\n      let attempts = 0;\n      while (attempts < CONFIG.maxPollingAttempts) {\n        await new Promise(resolve => setTimeout(resolve, CONFIG.pollingInterval));\n        attempts++;\n        const currentRequestId = appsmith.store?.availabilityRequestId;\n        const conflicts = appsmith.store?.availabilityConflicts;\n        if (currentRequestId === requestId && Array.isArray(conflicts)) {\n          addDebugLog(`✅ Verfügbarkeitsprüfung abgeschlossen nach ${attempts * CONFIG.pollingInterval}ms: ${conflicts.length} Konflikte`);\n          return {\n            available: conflicts.length === 0,\n            conflicts: conflicts\n          };\n        }\n        addDebugLog(`Polling Attempt ${attempts}/${CONFIG.maxPollingAttempts} - RequestID: ${currentRequestId}, Conflicts: ${conflicts?.length || 'undefined'}`);\n      }\n\n      // Timeout erreicht\n      addDebugLog(`⚠️ Verfügbarkeitsprüfung Timeout nach ${CONFIG.maxPollingAttempts * CONFIG.pollingInterval}ms - verwende Fallback`);\n      return {\n        available: true,\n        conflicts: []\n      };\n    } catch (error) {\n      addDebugLog(`Verfügbarkeitsprüfung fehlgeschlagen: ${error.message} - Task wird trotzdem erstellt`);\n      return {\n        available: true,\n        conflicts: []\n      };\n    }\n  };\n\n  // ─── TASK SELECTION ───\n  const handleTaskSelect = async (selectedTaskId, assignedEmployeeId, cellDay, cellTime) => {\n    addDebugLog(`🎯 Task Selection: ${selectedTaskId}, Employee: ${assignedEmployeeId}, Position: ${cellDay}-${cellTime}`);\n    if (!roomId || !cellDay || !cellTime) {\n      addDebugLog(\"❌ Abbruch: Fehlende Parameter\");\n      setActiveCell(null);\n      return;\n    }\n    const key = `${cellDay}-${cellTime}`;\n    const cellData = gridState[key] || null;\n\n    // Entfernen\n    if (selectedTaskId === \"\") {\n      addDebugLog(\"🗑️ Task entfernen gewählt\");\n      if (cellData?.root) {\n        if (cellData.existing && cellData.scheduleId) {\n          appsmith.updateModel({\n            scheduleIdToDelete: cellData.scheduleId\n          });\n          appsmith.triggerEvent(\"onDeleteSingle\");\n        }\n        removeBlockLocal(cellDay, cellTime);\n      }\n      setActiveCell(null);\n      return;\n    }\n\n    // Task finden\n    const taskObj = tasks.find(t => t.id === parseInt(selectedTaskId, 10));\n    if (!taskObj) {\n      addDebugLog(`❌ Task nicht gefunden: ${selectedTaskId}`);\n      setActiveCell(null);\n      return;\n    }\n    addDebugLog(`✅ Task gefunden: ${taskObj.name} (${taskObj.duration_minutes}min)`);\n\n    // Verfügbarkeitsprüfung\n    if (assignedEmployeeId) {\n      addDebugLog(\"🔍 STARTE VERFÜGBARKEITSPRÜFUNG\");\n      try {\n        // Loading-Anzeige\n        const originalActiveCell = activeCell;\n        setActiveCell({\n          ...originalActiveCell,\n          loading: true\n        });\n        const availability = await checkEmployeeAvailability(assignedEmployeeId, cellDay, cellTime, taskObj.duration_minutes);\n\n        // Loading entfernen\n        setActiveCell(originalActiveCell);\n        if (!availability.available && availability.conflicts.length > 0) {\n          const employeeName = employees.find(e => e.id == assignedEmployeeId)?.name || `Mitarbeiter ${assignedEmployeeId}`;\n          const conflictMsg = availability.conflicts.map(c => {\n            return `${c.start_time.slice(0, 5)}-${c.end_time.slice(0, 5)}: ${c.task_name}${c.room_name ? ` (${c.room_name})` : ''}`;\n          }).join('\\n');\n          const confirmed = window.confirm(`⚠️ MITARBEITER-KONFLIKT!\\n\\n${employeeName} ist bereits verplant:\\n\\n${conflictMsg}\\n\\nTrotzdem den Termin erstellen/ändern?`);\n          if (!confirmed) {\n            addDebugLog(\"❌ Task-Erstellung vom User abgebrochen wegen Konflikt\");\n            setActiveCell(null);\n            return;\n          } else {\n            addDebugLog(\"✅ User bestätigt Erstellung trotz Konflikt\");\n          }\n        } else {\n          addDebugLog(`✅ Mitarbeiter ist verfügbar - keine Konflikte gefunden`);\n        }\n      } catch (error) {\n        addDebugLog(`❌ Verfügbarkeitsprüfung Fehler: ${error.message} - erstelle Task trotzdem`);\n        setActiveCell(activeCell);\n      }\n    } else {\n      addDebugLog(\"ℹ️ Kein Mitarbeiter ausgewählt - überspringe Verfügbarkeitsprüfung\");\n    }\n\n    // Task erstellen/updaten\n    try {\n      if (cellData?.root && cellData.existing) {\n        addDebugLog(\"🔄 Update existierenden Task\");\n        updateSingleTask({\n          scheduleId: cellData.scheduleId,\n          newTaskId: parseInt(selectedTaskId, 10),\n          newDay: cellDay,\n          newTime: cellTime,\n          assignedEmployee: assignedEmployeeId\n        });\n        updateBlockInGrid(taskObj, cellDay, cellTime, assignedEmployeeId, cellData.scheduleId, true);\n      } else {\n        addDebugLog(\"🆕 Erstelle neuen Task\");\n        if (cellData?.root && !cellData.existing) {\n          removeBlockLocal(cellDay, cellTime);\n        }\n        createNewBlock(taskObj, cellDay, cellTime, assignedEmployeeId);\n        addDebugLog(`✅ Neuer Block erstellt für Task: ${taskObj.name}`);\n      }\n    } catch (error) {\n      addDebugLog(`❌ Fehler beim Task erstellen: ${error.message}`);\n    }\n    setActiveCell(null);\n  };\n\n  // ─── BLOCK MANAGEMENT ───\n  const removeBlockLocal = (day, time) => {\n    addDebugLog(`🗑️ Entferne Block: ${day}-${time}`);\n    setAllGridStates(prev => {\n      const copy = {\n        ...prev\n      };\n      const current = {\n        ...(copy[roomId] || {})\n      };\n      const key = `${day}-${time}`;\n      const cellData = current[key];\n      if (cellData?.root) {\n        const rowspan = cellData.rowspan || 1;\n        const slots = generateTimeSlots();\n        const startIdx = slots.indexOf(time);\n        for (let i = 0; i < rowspan; i++) {\n          const t = slots[startIdx + i];\n          if (!t) break;\n          delete current[`${day}-${t}`];\n        }\n      }\n      copy[roomId] = current;\n      return copy;\n    });\n  };\n  const createNewBlock = (taskObj, day, time, assignedEmployeeId = null) => {\n    addDebugLog(`🆕 Erstelle neuen Block: ${taskObj.name} bei ${day}-${time}`);\n    const slots = generateTimeSlots();\n    const startIdx = slots.indexOf(time);\n    const durationSlots = Math.ceil(taskObj.duration_minutes / CONFIG.slotMinutes);\n    setAllGridStates(prev => {\n      const copy = {\n        ...prev\n      };\n      const current = {\n        ...(copy[roomId] || {})\n      };\n      for (let i = 0; i < durationSlots; i++) {\n        const t = slots[startIdx + i];\n        if (!t) break;\n        current[`${day}-${t}`] = {\n          task: taskObj.name,\n          taskId: taskObj.id,\n          root: i === 0,\n          rowspan: durationSlots,\n          existing: false,\n          scheduleId: null,\n          assignedEmployee: assignedEmployeeId,\n          duration_minutes: taskObj.duration_minutes\n        };\n      }\n      copy[roomId] = current;\n      addDebugLog(`✅ Block erstellt: ${Object.keys(current).length} Zellen im Grid`);\n      return copy;\n    });\n  };\n  const updateBlockInGrid = (taskObj, day, time, assignedEmployeeId, scheduleId, existing) => {\n    const slots = generateTimeSlots();\n    const startIdx = slots.indexOf(time);\n    const durationSlots = Math.ceil(taskObj.duration_minutes / CONFIG.slotMinutes);\n    setAllGridStates(prev => {\n      const copy = {\n        ...prev\n      };\n      const current = {\n        ...(copy[roomId] || {})\n      };\n\n      // Entferne alte Zellen mit derselben scheduleId\n      Object.keys(current).forEach(key => {\n        if (current[key]?.scheduleId === scheduleId) {\n          delete current[key];\n        }\n      });\n\n      // Erstelle neue Zellen\n      for (let i = 0; i < durationSlots; i++) {\n        const t = slots[startIdx + i];\n        if (!t) break;\n        current[`${day}-${t}`] = {\n          task: taskObj.name,\n          taskId: taskObj.id,\n          root: i === 0,\n          rowspan: durationSlots,\n          existing: existing,\n          scheduleId: scheduleId,\n          assignedEmployee: assignedEmployeeId,\n          duration_minutes: taskObj.duration_minutes\n        };\n      }\n      copy[roomId] = current;\n      return copy;\n    });\n  };\n\n  // ─── EVENT HANDLERS ───\n  const updateSingleTask = ({\n    scheduleId,\n    newTaskId,\n    newDay,\n    newTime,\n    assignedEmployee\n  }) => {\n    addDebugLog(`🔄 updateSingleTask: scheduleId=${scheduleId}, taskId=${newTaskId}, employee=${assignedEmployee}`);\n    appsmith.updateModel({\n      updateSingleData: {\n        scheduleId,\n        newTaskId,\n        newDay,\n        newTime,\n        assignedEmployee,\n        roomId\n      }\n    });\n    appsmith.triggerEvent(\"onUpdateSingle\");\n  };\n  const deleteSingleTask = scheduleId => {\n    if (!scheduleId || !roomId) return;\n    addDebugLog(`🗑️ Lösche Task mit scheduleId: ${scheduleId}`);\n    appsmith.updateModel({\n      scheduleIdToDelete: scheduleId\n    });\n    appsmith.triggerEvent(\"onDeleteSingle\");\n    setAllGridStates(prev => {\n      const copy = {\n        ...prev\n      };\n      const current = {\n        ...(copy[roomId] || {})\n      };\n      const rootKey = Object.keys(current).find(key => current[key]?.scheduleId === scheduleId && current[key]?.root);\n      if (rootKey) {\n        const [day, time] = rootKey.split(\"-\");\n        removeBlockLocal(day, time);\n      }\n      copy[roomId] = current;\n      return copy;\n    });\n    setActiveCell(null);\n  };\n  const saveRoom = () => {\n    if (!roomId) return;\n    const newEntries = {};\n    Object.entries(gridState).forEach(([key, cellData]) => {\n      if (!cellData.root) return;\n      if (cellData.existing) return;\n      newEntries[key] = cellData;\n    });\n    addDebugLog(`💾 Speichere ${Object.keys(newEntries).length} neue Einträge`);\n    if (Object.keys(newEntries).length === 0) {\n      addDebugLog(\"ℹ️ Keine neuen Einträge zum Speichern\");\n      window.alert(\"Keine neuen Termine zum Speichern vorhanden.\");\n      return;\n    }\n    const payload = {\n      roomId,\n      gridState: JSON.parse(JSON.stringify(newEntries)),\n      fullGridState: JSON.parse(JSON.stringify(gridState))\n    };\n    appsmith.updateModel({\n      lastSaveData: payload\n    });\n    try {\n      appsmith.triggerEvent(\"onSaveRoom\");\n      addDebugLog(\"✅ Event erfolgreich ausgelöst\");\n      setAllGridStates(prev => {\n        const copy = {\n          ...prev\n        };\n        const current = {\n          ...(copy[roomId] || {})\n        };\n        Object.keys(newEntries).forEach(key => {\n          if (current[key]) {\n            current[key] = {\n              ...current[key],\n              existing: true\n            };\n          }\n        });\n        copy[roomId] = current;\n        return copy;\n      });\n    } catch (error) {\n      addDebugLog(`❌ Event-Fehler: ${error.message}`);\n    }\n  };\n  const resetRoom = () => {\n    if (!roomId) return;\n    addDebugLog(\"🔄 Raum zurücksetzen - nur lokale ungespeicherte Änderungen\");\n    setAllGridStates(prev => {\n      const copy = {\n        ...prev\n      };\n      const current = {\n        ...(copy[roomId] || {})\n      };\n      let removedCount = 0;\n      const keysToRemove = [];\n      Object.entries(current).forEach(([key, cellData]) => {\n        if (cellData && !cellData.existing) {\n          keysToRemove.push(key);\n          if (cellData.root) removedCount++;\n        }\n      });\n      keysToRemove.forEach(key => {\n        delete current[key];\n      });\n      addDebugLog(`✅ ${removedCount} ungespeicherte Tasks entfernt, DB-Tasks bleiben erhalten`);\n      copy[roomId] = current;\n      return copy;\n    });\n  };\n  const deleteRoomData = async () => {\n    if (!roomId) {\n      window.alert(\"Bitte zuerst einen Raum auswählen.\");\n      return;\n    }\n    addDebugLog(\"🗑️ Alle Raum-Daten löschen\");\n    appsmith.updateModel({\n      initialData: {}\n    });\n    appsmith.triggerEvent(\"onDeleteAllRoom\");\n    setAllGridStates(prev => {\n      const copy = {\n        ...prev\n      };\n      copy[roomId] = {};\n      return copy;\n    });\n    setActiveCell(null);\n  };\n  const prepareTableData = () => {\n    if (!roomId) return [];\n    const currentGrid = allGridStates[roomId] || {};\n    const timeSlots = generateTimeSlots();\n    const tableData = [];\n    tableData.push({\n      Zeit: `RAUM: ${roomName || `Raum ${roomId}`} (ID: ${roomId})`,\n      Mo: \"\",\n      Di: \"\",\n      Mi: \"\",\n      Do: \"\",\n      Fr: \"\"\n    });\n    tableData.push({\n      Zeit: \"\",\n      Mo: \"\",\n      Di: \"\",\n      Mi: \"\",\n      Do: \"\",\n      Fr: \"\"\n    });\n    tableData.push({\n      Zeit: \"ZEIT\",\n      Mo: \"MONTAG\",\n      Di: \"DIENSTAG\",\n      Mi: \"MITTWOCH\",\n      Do: \"DONNERSTAG\",\n      Fr: \"FREITAG\"\n    });\n    for (let time of timeSlots) {\n      const row = {\n        Zeit: time\n      };\n      for (let day of CONFIG.days) {\n        const key = `${day}-${time}`;\n        const cell = currentGrid[key];\n        if (cell && cell.root) {\n          let cellContent = cell.task;\n          if (cell.assignedEmployee) {\n            const emp = employees.find(e => e.id == cell.assignedEmployee);\n            const empName = emp?.name || `MA${cell.assignedEmployee}`;\n            cellContent += ` [${empName}]`;\n          }\n          row[day] = cellContent;\n        } else {\n          row[day] = \"\";\n        }\n      }\n      tableData.push(row);\n    }\n    return tableData;\n  };\n  React.useEffect(() => {\n    const tableData = prepareTableData();\n    const entityName = roomName || `Raum_${roomId}`;\n    const cleanName = entityName.replace(/[^a-zA-Z0-9äöüÄÖÜß]/g, '_');\n    appsmith.updateModel({\n      tableData: tableData,\n      hasTableData: tableData.length > 0,\n      roomId: roomId,\n      exportFileName: `Raumplan_${cleanName}_${roomId}_${new Date().toISOString().split('T')[0]}`,\n      currentRoomName: entityName\n    });\n  }, [allGridStates, roomId, roomName]);\n  const openExportModal = () => {\n    if (!roomId) {\n      window.alert(\"Bitte zuerst einen Raum auswählen, um zu exportieren.\");\n      return;\n    }\n    const tableData = prepareTableData();\n    if (tableData.length <= 3) {\n      window.alert(\"Raum-Grid ist leer. Nichts zum Exportieren.\");\n      return;\n    }\n    appsmith.updateModel({\n      tableData: tableData,\n      exportFileName: `Raumplan_${roomName}_${roomId}_${new Date().toISOString().split('T')[0]}`,\n      currentRoomName: roomName\n    });\n    appsmith.triggerEvent(\"onOpenExportModal\");\n  };\n  const onDragStart = (e, day, time) => {\n    e.dataTransfer.setData(\"text/plain\", JSON.stringify({\n      day,\n      time\n    }));\n    setDragSource({\n      day,\n      time\n    });\n  };\n  const onDragOver = e => e.preventDefault();\n  const onDrop = (e, targetDay, targetTime) => {\n    e.preventDefault();\n    setDragSource(null);\n  };\n\n  // ─── MEMOIZED CALCULATIONS ───\n  const skipCells = React.useMemo(() => {\n    const result = {};\n    const timeSlots = generateTimeSlots();\n    Object.entries(gridState).forEach(([key, cellData]) => {\n      if (cellData.root) {\n        const [day, time] = key.split(\"-\");\n        const idx = timeSlots.indexOf(time);\n        for (let i = 1; i < cellData.rowspan; i++) {\n          const next = timeSlots[idx + i];\n          if (next) {\n            result[`${day}-${next}`] = true;\n          }\n        }\n      }\n    });\n    return result;\n  }, [gridState]);\n  const handleCellClick = React.useCallback((day, time) => {\n    if (!roomId) {\n      window.alert(\"Bitte zuerst einen Raum auswählen.\");\n      return;\n    }\n    addDebugLog(`🎯 Zelle ${day}-${time} angeklickt`);\n    setActiveCell({\n      day,\n      time\n    });\n  }, [roomId, addDebugLog]);\n\n  // ─── RENDER GRID ───\n  const renderGrid = () => {\n    const timeSlots = generateTimeSlots();\n    return /*#__PURE__*/React.createElement(\"div\", {\n      className: \"widget-container\"\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      className: \"room-header\"\n    }, /*#__PURE__*/React.createElement(\"h3\", null, \"\\uD83C\\uDFE2 Raumplanung - Verf\\xFCgbarkeitspr\\xFCfung\"), /*#__PURE__*/React.createElement(\"div\", {\n      className: \"room-info\"\n    }, /*#__PURE__*/React.createElement(\"strong\", null, \"Aktueller Raum:\"), \" \", roomName || 'Kein Raum ausgewählt', roomId && ` (ID: ${roomId})`), /*#__PURE__*/React.createElement(\"div\", {\n      className: \"room-details\"\n    }, \"\\uD83D\\uDD0D Automatische Verf\\xFCgbarkeitspr\\xFCfung bei Mitarbeiter-Zuweisung\"), /*#__PURE__*/React.createElement(\"div\", {\n      className: \"room-details\"\n    }, \"\\uD83D\\uDCCA Grid-Status: \", Object.keys(gridState).length, \" Zellen aktiv\")), hasChanges && /*#__PURE__*/React.createElement(\"div\", {\n      className: \"unsaved-warning\"\n    }, /*#__PURE__*/React.createElement(\"span\", null, \"\\u26A0\\uFE0F\"), /*#__PURE__*/React.createElement(\"span\", null, \"Du hast ungespeicherte \\xC4nderungen!\")), /*#__PURE__*/React.createElement(\"div\", {\n      className: \"button-row\"\n    }, /*#__PURE__*/React.createElement(\"button\", {\n      className: \"modern-btn btn-reset\",\n      onClick: resetRoom\n    }, /*#__PURE__*/React.createElement(\"span\", null, \"\\uD83D\\uDD04\"), \"Zur\\xFCcksetzen (Raum)\"), /*#__PURE__*/React.createElement(\"button\", {\n      className: \"modern-btn btn-delete-all\",\n      onClick: deleteRoomData\n    }, /*#__PURE__*/React.createElement(\"span\", null, \"\\uD83D\\uDDD1\\uFE0F\"), \"Alle Termine l\\xF6schen\"), /*#__PURE__*/React.createElement(\"button\", {\n      className: \"modern-btn btn-save\",\n      onClick: saveRoom\n    }, /*#__PURE__*/React.createElement(\"span\", null, \"\\uD83D\\uDCBE\"), \"Speichern \", hasChanges && '(!)'), /*#__PURE__*/React.createElement(\"button\", {\n      className: \"modern-btn btn-export\",\n      onClick: openExportModal\n    }, /*#__PURE__*/React.createElement(\"span\", null, \"\\uD83D\\uDCCA\"), \"Excel/CSV Export\")), /*#__PURE__*/React.createElement(\"table\", {\n      className: \"grid-table\"\n    }, /*#__PURE__*/React.createElement(\"thead\", null, /*#__PURE__*/React.createElement(\"tr\", null, /*#__PURE__*/React.createElement(\"th\", {\n      className: \"time-cell\"\n    }, \"\\u23F0 Zeit\"), CONFIG.days.map(day => /*#__PURE__*/React.createElement(\"th\", {\n      key: day,\n      className: \"day-cell\"\n    }, \"\\uD83D\\uDCC5 \", day)))), /*#__PURE__*/React.createElement(\"tbody\", null, timeSlots.map((time, rowIdx) => /*#__PURE__*/React.createElement(\"tr\", {\n      key: time\n    }, /*#__PURE__*/React.createElement(\"td\", {\n      className: \"time-cell\"\n    }, time), CONFIG.days.map(day => {\n      const key = `${day}-${time}`;\n      if (skipCells[key]) return null;\n      const cellData = gridState[key];\n      const isActive = activeCell?.day === day && activeCell?.time === time;\n\n      // Task-Zelle\n      if (cellData?.root) {\n        return /*#__PURE__*/React.createElement(\"td\", {\n          key: key,\n          rowSpan: cellData.rowspan,\n          className: \"task-cell\",\n          style: {\n            backgroundColor: getModernTaskColor(cellData.task)\n          },\n          draggable: \"true\",\n          onDragStart: e => onDragStart(e, day, time),\n          onDragOver: onDragOver\n        }, !cellData.existing && /*#__PURE__*/React.createElement(\"div\", {\n          className: \"unsaved-badge\"\n        }), /*#__PURE__*/React.createElement(\"div\", {\n          className: \"task-content\"\n        }, isActive ? /*#__PURE__*/React.createElement(RoomPlanningDropdown, {\n          tasks: tasks,\n          employees: employees,\n          currentTask: cellData.task,\n          currentEmployee: cellData.assignedEmployee,\n          onSelect: (taskId, employeeId) => handleTaskSelect(taskId, employeeId, day, time),\n          onCancel: () => setActiveCell(null),\n          isInTableCell: true,\n          loading: activeCell?.loading || false\n        }) : /*#__PURE__*/React.createElement(\"div\", {\n          style: {\n            display: 'flex',\n            flexDirection: 'column',\n            gap: '4px'\n          }\n        }, /*#__PURE__*/React.createElement(\"span\", {\n          className: \"task-name\",\n          onClick: () => handleCellClick(day, time),\n          style: {\n            color: '#333'\n          }\n        }, cellData.task), cellData.assignedEmployee && /*#__PURE__*/React.createElement(\"div\", {\n          className: \"task-employee-badge\"\n        }, \"\\uD83D\\uDC64 \", employees.find(e => e.id == cellData.assignedEmployee)?.name || `MA${cellData.assignedEmployee}`)), cellData.existing && cellData.scheduleId && /*#__PURE__*/React.createElement(\"button\", {\n          className: \"delete-icon\",\n          onClick: () => deleteSingleTask(cellData.scheduleId),\n          title: \"Diesen Task l\\xF6schen\"\n        }, \"\\uD83D\\uDDD1\\uFE0F\")));\n      }\n\n      // Freie Zelle\n      return /*#__PURE__*/React.createElement(\"td\", {\n        key: key,\n        className: \"empty-cell\",\n        onClick: () => handleCellClick(day, time),\n        onDragOver: onDragOver,\n        onDrop: e => onDrop(e, day, time)\n      }, isActive ? /*#__PURE__*/React.createElement(RoomPlanningDropdown, {\n        tasks: tasks,\n        employees: employees,\n        onSelect: (taskId, employeeId) => handleTaskSelect(taskId, employeeId, day, time),\n        onCancel: () => setActiveCell(null),\n        isInTableCell: true,\n        loading: activeCell?.loading || false\n      }) : null);\n    }))))));\n  };\n  return renderGrid();\n}\nfunction render() {\n  ReactDOM.render(/*#__PURE__*/React.createElement(App, null), document.getElementById(\"root\"));\n}\nappsmith.onReady(() => {\n  render();\n});\nappsmith.onModelChange(() => {\n  render();\n});"
  },
  "theme": "{{appsmith.theme}}",
  "topRow": 7,
  "type": "CUSTOM_WIDGET",
  "uncompiledSrcDoc": {
    "css": "/* ─── Appsmith-konforme Schriftart ─── */\n* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n    font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;\n}\n\n/* ─── Container ─── */\n.widget-container {\n    padding: 16px;\n    background: #fafafa;\n    border-radius: 4px;\n    font-size: 14px;\n    color: #212529;\n}\n\n/* ─── Unsaved Changes Warning ─── */\n.unsaved-warning {\n    background: linear-gradient(135deg, #FF4757, #FF6348);\n    color: white;\n    padding: 12px 16px;\n    border-radius: 8px;\n    margin-bottom: 16px;\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    font-weight: 600;\n    box-shadow: 0 4px 12px rgba(255, 71, 87, 0.3);\n    animation: pulse-warning 2s infinite;\n}\n\n@keyframes pulse-warning {\n    0%, 100% { opacity: 1; }\n    50% { opacity: 0.8; }\n}\n\n/* ─── Room Header Section ─── */\n.room-header {\n    background: linear-gradient(135deg, #17a2b8, #138496);\n    color: white;\n    padding: 15px;\n    border-radius: 8px;\n    margin-bottom: 20px;\n    box-shadow: 0 4px 15px rgba(23, 162, 184, 0.3);\n}\n\n.room-header h3 {\n    margin: 0 0 8px 0;\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    font-size: 16px;\n    font-weight: 600;\n}\n\n.room-info {\n    font-size: 14px;\n    margin-bottom: 4px;\n}\n\n.room-details {\n    font-size: 12px;\n    opacity: 0.9;\n    margin-top: 4px;\n}\n\n/* ─── Debug Panel ─── */\n.debug-panel {\n    margin-bottom: 15px;\n    padding: 12px;\n    background: linear-gradient(135deg, #f8f9fa, #e9ecef);\n    border: 1px solid #dee2e6;\n    border-radius: 8px;\n    font-size: 12px;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n}\n\n.debug-title {\n    font-weight: 600;\n    margin-bottom: 8px;\n    color: #495057;\n    display: flex;\n    align-items: center;\n    gap: 6px;\n}\n\n.debug-log-item {\n    margin: 3px 0;\n    color: #495057;\n    padding: 2px 0;\n    border-bottom: 1px solid rgba(222, 226, 230, 0.5);\n}\n\n.debug-clear-btn {\n    margin-top: 8px;\n    padding: 4px 8px;\n    font-size: 11px;\n    border: 1px solid #dee2e6;\n    background: white;\n    border-radius: 4px;\n    cursor: pointer;\n    transition: all 0.2s ease;\n}\n\n.debug-clear-btn:hover {\n    background: #f8f9fa;\n    transform: translateY(-1px);\n}\n\n/* ─── Modern Button Row ─── */\n.button-row {\n    display: flex;\n    gap: 12px;\n    margin-bottom: 20px;\n    flex-wrap: wrap;\n}\n\n.modern-btn {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    padding: 12px 20px;\n    border: none;\n    border-radius: 8px;\n    font-size: 14px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);\n    text-decoration: none;\n    min-height: 44px;\n    position: relative;\n    overflow: hidden;\n}\n\n.modern-btn::before {\n    content: '';\n    position: absolute;\n    top: 0;\n    left: -100%;\n    width: 100%;\n    height: 100%;\n    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);\n    transition: left 0.5s;\n}\n\n.modern-btn:hover::before {\n    left: 100%;\n}\n\n.btn-reset {\n    background: linear-gradient(135deg, #667eea, #764ba2);\n    color: white;\n    box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);\n}\n\n.btn-reset:hover {\n    transform: translateY(-2px);\n    box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);\n}\n\n.btn-delete-all {\n    background: linear-gradient(135deg, #ff6b6b, #ee5a52);\n    color: white;\n    box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);\n}\n\n.btn-delete-all:hover {\n    transform: translateY(-2px);\n    box-shadow: 0 8px 25px rgba(255, 107, 107, 0.4);\n}\n\n.btn-save {\n    background: linear-gradient(135deg, #51cf66, #40c057);\n    color: white;\n    box-shadow: 0 4px 15px rgba(81, 207, 102, 0.3);\n}\n\n.btn-save:hover {\n    transform: translateY(-2px);\n    box-shadow: 0 8px 25px rgba(81, 207, 102, 0.4);\n}\n\n.btn-export {\n    background: linear-gradient(135deg, #339af0, #228be6);\n    color: white;\n    box-shadow: 0 4px 15px rgba(51, 154, 240, 0.3);\n}\n\n.btn-export:hover {\n    transform: translateY(-2px);\n    box-shadow: 0 8px 25px rgba(51, 154, 240, 0.4);\n}\n\n/* ─── Modern Grid Table ─── */\n.grid-table {\n    width: 100%;\n    border-collapse: separate;\n    border-spacing: 0;\n    background: white;\n    border-radius: 12px;\n    overflow: hidden;\n    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);\n    border: 1px solid #e9ecef;\n    table-layout: fixed;\n}\n\n.grid-table th {\n    background: linear-gradient(135deg, #495057, #343a40);\n    color: white;\n    padding: 16px 8px;\n    text-align: center;\n    font-weight: 700;\n    font-size: 13px;\n    text-transform: uppercase;\n    letter-spacing: 0.5px;\n    border-bottom: 3px solid #212529;\n}\n\n.grid-table th:first-child {\n    width: 80px;\n    min-width: 80px;\n}\n\n.grid-table th:not(:first-child) {\n    width: calc((100% - 80px) / 5);\n}\n\n.grid-table td {\n    padding: 6px;\n    text-align: center;\n    border: 1px solid #e9ecef;\n    background: white;\n    position: relative;\n    min-height: 36px;\n    transition: all 0.15s ease;\n}\n\n.grid-table td:hover {\n    background: #f8f9fa !important;\n    transform: scale(1.02);\n    z-index: 10;\n}\n\n.time-cell {\n    background: #f8f9fa !important;\n    font-weight: 600;\n    color: #495057;\n    width: 80px;\n    font-size: 12px;\n    border-right: 2px solid #dee2e6;\n}\n\n.task-cell {\n    cursor: move;\n    border-radius: 6px;\n    padding: 10px;\n    font-weight: 600;\n    font-size: 13px;\n    position: relative;\n    overflow: hidden;\n    border: 2px solid rgba(255, 255, 255, 0.8) !important;\n}\n\n.task-cell::before {\n    content: '';\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    background: linear-gradient(135deg, rgba(255,255,255,0.3), rgba(255,255,255,0.1));\n    pointer-events: none;\n}\n\n.task-cell:hover {\n    transform: translateY(-2px) scale(1.02);\n    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);\n}\n\n/* ─── Searchable Dropdown ─── */\n.search-dropdown {\n    position: relative;\n    width: 100%;\n    z-index: 9999;\n}\n\n.search-input {\n    width: 100%;\n    padding: 10px 12px;\n    border: 2px solid #e9ecef;\n    border-radius: 8px;\n    font-size: 13px;\n    font-weight: 500;\n    outline: none;\n    transition: all 0.2s ease;\n    background: white;\n    min-height: 36px;\n}\n\n.search-input:focus {\n    border-color: #17a2b8;\n    box-shadow: 0 0 0 3px rgba(23, 162, 184, 0.15);\n    background: #fff;\n}\n\n.search-input:disabled {\n    background: #fff3cd;\n    border-color: #ffc107;\n    cursor: wait;\n}\n\n/* ─── Dropdown List ─── */\n.dropdown-list {\n    position: fixed;\n    background: white;\n    border: 2px solid #e9ecef;\n    border-radius: 8px;\n    max-height: 450px;\n    overflow-y: auto;\n    z-index: 99999;\n    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.25);\n    min-width: 350px;\n    animation: dropdownSlideDown 0.15s ease-out;\n}\n\n/* ─── Standard Dropdown in Zellen ─── */\n.search-dropdown .dropdown-list:not([style*=\"position: fixed\"]) {\n    position: absolute;\n    left: 0;\n    right: 0;\n    top: 100%;\n    margin-top: 2px;\n    z-index: 1000;\n}\n\n@keyframes dropdownSlideDown {\n    from {\n        opacity: 0;\n        transform: translateY(-8px) scale(0.98);\n    }\n    to {\n        opacity: 1;\n        transform: translateY(0) scale(1);\n    }\n}\n\n.dropdown-header {\n    padding: 12px 16px;\n    background: linear-gradient(135deg, #17a2b8, #138496);\n    color: white;\n    font-weight: 600;\n    font-size: 13px;\n    display: flex;\n    align-items: center;\n    gap: 6px;\n}\n\n.dropdown-loading {\n    padding: 15px 12px;\n    text-align: center;\n    background: #fff3cd;\n    border-bottom: 1px solid #dee2e6;\n    color: #856404;\n    font-size: 13px;\n    font-weight: 600;\n}\n\n.dropdown-item {\n    padding: 12px 16px;\n    cursor: pointer;\n    border-bottom: 1px solid #f8f9fa;\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    font-size: 13px;\n    font-weight: 500;\n    transition: all 0.1s ease;\n}\n\n.dropdown-item:hover {\n    background: #f8f9fa;\n    transform: translateX(4px);\n}\n\n.dropdown-item:last-child {\n    border-bottom: none;\n}\n\n.dropdown-item.remove-item {\n    color: #e03131;\n    font-weight: 600;\n}\n\n.dropdown-item.remove-item:hover {\n    background: #fff5f5;\n}\n\n.employee-select-section {\n    padding: 12px;\n    border-bottom: 2px solid #e9ecef;\n    background: #f8f9fa;\n}\n\n.employee-select-label {\n    font-size: 12px;\n    font-weight: 600;\n    color: #495057;\n    margin-bottom: 6px;\n    display: block;\n}\n\n.employee-select {\n    width: 100%;\n    padding: 6px 8px;\n    border: 1px solid #dee2e6;\n    border-radius: 4px;\n    font-size: 13px;\n    background: white;\n    transition: all 0.2s ease;\n}\n\n.employee-select:focus {\n    border-color: #17a2b8;\n    box-shadow: 0 0 0 2px rgba(23, 162, 184, 0.2);\n}\n\n.employee-success-msg {\n    font-size: 11px;\n    color: #28a745;\n    margin-top: 4px;\n    display: flex;\n    align-items: center;\n    gap: 4px;\n}\n\n.task-color-preview {\n    width: 16px;\n    height: 16px;\n    border-radius: 4px;\n    border: 2px solid rgba(255, 255, 255, 0.8);\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n\n.task-duration {\n    font-size: 11px;\n    color: #868e96;\n    margin-left: auto;\n    font-weight: 600;\n    background: #f8f9fa;\n    padding: 2px 6px;\n    border-radius: 4px;\n}\n\n/* ─── Delete Button ─── */\n.delete-icon {\n    background: rgba(255, 255, 255, 0.95);\n    border: none;\n    border-radius: 6px;\n    padding: 6px;\n    cursor: pointer;\n    margin-left: 8px;\n    transition: all 0.2s ease;\n    font-size: 14px;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n}\n\n.delete-icon:hover {\n    background: #ff6b6b;\n    transform: scale(1.15);\n    box-shadow: 0 4px 12px rgba(255, 107, 107, 0.3);\n}\n\n/* ─── Unsaved Changes Badge ─── */\n.unsaved-badge {\n    position: absolute;\n    top: -4px;\n    right: -4px;\n    background: #ff6b6b;\n    color: white;\n    border-radius: 50%;\n    width: 12px;\n    height: 12px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-size: 8px;\n    font-weight: bold;\n    animation: pulse-badge 1.5s infinite;\n    border: 2px solid white;\n    box-shadow: 0 2px 8px rgba(255, 107, 107, 0.4);\n}\n\n@keyframes pulse-badge {\n    0%, 100% { transform: scale(1); }\n    50% { transform: scale(1.2); }\n}\n\n/* ─── Task Content ─── */\n.task-content {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    position: relative;\n    z-index: 10;\n}\n\n.task-name {\n    flex: 1;\n    cursor: pointer;\n    padding: 6px;\n    border-radius: 4px;\n    transition: all 0.2s ease;\n    font-weight: 600;\n}\n\n.task-name:hover {\n    background: rgba(255, 255, 255, 0.3);\n    transform: scale(1.05);\n}\n\n.task-employee-badge {\n    font-size: 11px;\n    opacity: 0.9;\n    background: rgba(255, 255, 255, 0.2);\n    padding: 2px 4px;\n    border-radius: 3px;\n    margin-top: 2px;\n    display: flex;\n    align-items: center;\n    gap: 2px;\n}\n\n/* ─── Empty Cell ─── */\n.empty-cell {\n    cursor: pointer;\n    transition: all 0.2s ease;\n    position: relative;\n}\n\n.empty-cell:hover {\n    background: #e3f2fd !important;\n}\n\n.empty-cell::after {\n    content: '+';\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    font-size: 16px;\n    color: #868e96;\n    opacity: 0;\n    transition: opacity 0.2s ease;\n}\n\n.empty-cell:hover::after {\n    opacity: 1;\n}\n\n/* ─── Mobile & Touch Optimierungen ─── */\n@media (max-width: 768px) {\n    .widget-container {\n        padding: 12px;\n    }\n\n    .button-row {\n        flex-direction: column;\n        gap: 8px;\n    }\n    \n    .modern-btn {\n        justify-content: center;\n        min-height: 48px;\n        font-size: 16px;\n    }\n    \n    .grid-table {\n        font-size: 12px;\n    }\n    \n    .grid-table th, .grid-table td {\n        padding: 8px 4px;\n        min-height: 44px;\n    }\n\n    .grid-table th:first-child {\n        width: 60px;\n        min-width: 60px;\n    }\n\n    .grid-table th:not(:first-child) {\n        width: calc((100% - 60px) / 5);\n    }\n\n    .task-cell {\n        min-height: 44px;\n        padding: 8px;\n    }\n\n    .search-input {\n        font-size: 16px;\n        min-height: 44px;\n        padding: 12px;\n    }\n\n    .dropdown-item {\n        padding: 16px 12px;\n        min-height: 48px;\n        font-size: 14px;\n    }\n\n    .delete-icon {\n        padding: 8px;\n        min-height: 44px;\n        min-width: 44px;\n    }\n\n    .dropdown-list {\n        min-width: 300px;\n    }\n}\n\n@media (max-width: 480px) {\n    .grid-table th, .grid-table td {\n        padding: 6px 2px;\n        font-size: 11px;\n    }\n\n    .grid-table th:first-child {\n        width: 50px;\n        min-width: 50px;\n    }\n\n    .grid-table th:not(:first-child) {\n        width: calc((100% - 50px) / 5);\n    }\n\n    .modern-btn {\n        padding: 12px 16px;\n    }\n\n    .dropdown-list {\n        left: 8px !important;\n        right: 8px;\n        width: calc(100vw - 16px) !important;\n        min-width: unset !important;\n    }\n}\n\n/* ─── Touch-Geräte Optimierungen ─── */\n@media (hover: none) and (pointer: coarse) {\n    .task-cell:hover,\n    .grid-table td:hover,\n    .empty-cell:hover {\n        transform: none;\n        background: inherit !important;\n    }\n\n    .modern-btn:hover {\n        transform: none;\n    }\n\n    .dropdown-item:hover {\n        transform: none;\n    }\n\n    .task-name:hover {\n        transform: none;\n        background: rgba(255, 255, 255, 0.2);\n    }\n\n    .dropdown-list {\n        max-height: 60vh;\n        border-radius: 12px;\n    }\n\n    .dropdown-item {\n        border-bottom: 1px solid #f1f3f4;\n    }\n}\n\n/* ─── Scrollbar Styling ─── */\n.dropdown-list::-webkit-scrollbar {\n    width: 6px;\n}\n\n.dropdown-list::-webkit-scrollbar-track {\n    background: #f8f9fa;\n}\n\n.dropdown-list::-webkit-scrollbar-thumb {\n    background: #dee2e6;\n    border-radius: 3px;\n}\n\n.dropdown-list::-webkit-scrollbar-thumb:hover {\n    background: #adb5bd;\n}",
    "html": "<!-- no need to write html, head, body tags, it is handled by the widget -->\n<div id=\"root\"></div>\n",
    "js": "// ─── ROOM PLANNING WIDGET - MIT MASTER-DESIGN ───\n\nimport React from \"https://esm.sh/react@18.2.0\";\nimport ReactDOM from \"https://esm.sh/react-dom@18.2.0\";\nimport * as XLSX from \"https://esm.sh/xlsx@0.18.5\";\n\n// ─── ERWEITERTE FARBPALETTE - 80 EINZIGARTIGE FARBEN ───\nconst MODERN_TASK_COLORS = [\n  // Rot-Familie (10 Farben)\n  '#FF6B6B', '#FF4757', '#FF3838', '#FF6347', '#E74C3C', \n  '#C0392B', '#E55039', '#FA8072', '#DC143C', '#B22222',\n  \n  // Rosa-Familie (10 Farben)\n  '#FF69B4', '#FFB6C1', '#FFC0CB', '#FF1493', '#DA70D6',\n  '#BA55D3', '#DDA0DD', '#EE82EE', '#FF20FF', '#C71585',\n  \n  // Orange-Familie (10 Farben)\n  '#FFB347', '#FF7F50', '#FF8C00', '#FFA500', '#EB984E',\n  '#D2691E', '#F39C12', '#E67E22', '#CD853F', '#FF4500',\n  \n  // Gelb-Familie (10 Farben)\n  '#FFEAA7', '#F7DC6F', '#F4D03F', '#F1C40F', '#FFD700',\n  '#FFFF99', '#F9E79F', '#FAD7A0', '#FFFACD', '#FFFFE0',\n  \n  // Grün-Familie (10 Farben)\n  '#96CEB4', '#82E0AA', '#A9DFBF', '#52C41A', '#2ECC71',\n  '#27AE60', '#98D8C8', '#40E0D0', '#00FA9A', '#32CD32',\n  \n  // Türkis-Familie (10 Farben)\n  '#4ECDC4', '#A3E4D7', '#00CED1', '#1ABC9C', '#20B2AA',\n  '#48CAE4', '#00B4D8', '#0077B6', '#023E8A', '#03045E',\n  \n  // Blau-Familie (10 Farben)\n  '#45B7D1', '#85C1E9', '#AED6F1', '#3498DB', '#2980B9',\n  '#87CEEB', '#4682B4', '#6495ED', '#4169E1', '#0000FF',\n  \n  // Lila-Familie (10 Farben)\n  '#BB8FCE', '#D7BDE2', '#9B59B6', '#8E44AD', '#663399',\n  '#9370DB', '#8A2BE2', '#7B68EE', '#6A5ACD', '#483D8B'\n];\n\n// ─── KONFIGURATION ───\nconst CONFIG = {\n  days: [\"Mo\", \"Di\", \"Mi\", \"Do\", \"Fr\"],\n  startHour: 7,\n  endHour: 18,\n  slotMinutes: 15,\n  maxPollingAttempts: 25,\n  pollingInterval: 200\n};\n\n// ─── HILFSFUNKTIONEN ───\nfunction getModernTaskColor(taskName) {\n  let hash = 0;\n  for (let i = 0; i < taskName.length; i++) {\n    hash = taskName.charCodeAt(i) + ((hash << 5) - hash);\n  }\n  const index = Math.abs(hash) % MODERN_TASK_COLORS.length;\n  return MODERN_TASK_COLORS[index];\n}\n\nfunction generateTimeSlots() {\n  const slots = [];\n  for (let h = CONFIG.startHour; h < CONFIG.endHour; h++) {\n    for (let m = 0; m < 60; m += CONFIG.slotMinutes) {\n      const hh = String(h).padStart(2, \"0\");\n      const mm = String(m).padStart(2, \"0\");\n      slots.push(`${hh}:${mm}`);\n    }\n  }\n  return slots;\n}\n\nfunction hasUnsavedChanges(gridState) {\n  const unsavedCells = Object.values(gridState).filter(cell => \n    cell && cell.root && !cell.existing\n  );\n  \n  console.log(\"🔍 hasUnsavedChanges Debug:\");\n  console.log(\"  Alle root Zellen:\", Object.values(gridState).filter(cell => cell && cell.root));\n  console.log(\"  Ungespeicherte Zellen:\", unsavedCells);\n  console.log(\"  Ergebnis:\", unsavedCells.length > 0);\n  \n  return unsavedCells.length > 0;\n}\n\nfunction calculateEndTime(startTime, durationMinutes) {\n  const [hours, minutes] = startTime.split(':').map(Number);\n  const startMinutes = hours * 60 + minutes;\n  const endMinutes = startMinutes + durationMinutes;\n  const endHours = Math.floor(endMinutes / 60);\n  const endMins = endMinutes % 60;\n  return `${String(endHours).padStart(2, '0')}:${String(endMins).padStart(2, '0')}`;\n}\n\n// ─── DROPDOWN KOMPONENTE ───\nfunction RoomPlanningDropdown({ \n  tasks, \n  employees = [], \n  onSelect, \n  onCancel, \n  currentTask = null, \n  currentEmployee = null,\n  isInTableCell = false,\n  loading = false\n}) {\n  const [searchTerm, setSearchTerm] = React.useState('');\n  const [selectedEmployee, setSelectedEmployee] = React.useState(currentEmployee || '');\n  const [dropdownPosition, setDropdownPosition] = React.useState({ \n    top: 0, \n    left: 0, \n    width: 200,\n    maxHeight: 450\n  });\n  const [portalContainer, setPortalContainer] = React.useState(null);\n  const inputRef = React.useRef(null);\n  const dropdownRef = React.useRef(null);\n\n  React.useEffect(() => {\n    if (!inputRef.current) return;\n\n    inputRef.current.focus();\n    \n    // Portal Container erstellen\n    const container = document.createElement('div');\n    container.style.position = 'absolute';\n    container.style.top = '0';\n    container.style.left = '0';\n    container.style.zIndex = '10000';\n    document.body.appendChild(container);\n    setPortalContainer(container);\n    \n    // Position berechnen\n    const rect = inputRef.current.getBoundingClientRect();\n    const viewportHeight = window.innerHeight;\n    const spaceBelow = viewportHeight - rect.bottom;\n    const maxDropdownHeight = Math.max(200, spaceBelow - 20);\n    \n    setDropdownPosition({\n      top: rect.bottom + window.scrollY + 4,\n      left: rect.left + window.scrollX,\n      width: Math.max(rect.width, 350),\n      maxHeight: Math.min(450, maxDropdownHeight)\n    });\n    \n    // Auto-scroll wenn nötig\n    setTimeout(() => {\n      const dropdownBottom = rect.bottom + Math.min(450, maxDropdownHeight);\n      if (dropdownBottom > viewportHeight) {\n        const scrollOffset = dropdownBottom - viewportHeight + 20;\n        window.scrollBy({\n          top: scrollOffset,\n          behavior: 'smooth'\n        });\n      }\n    }, 50);\n    \n    return () => {\n      if (container && document.body.contains(container)) {\n        document.body.removeChild(container);\n      }\n    };\n  }, []);\n\n  const filteredTasks = tasks.filter(task =>\n    task.name.toLowerCase().includes(searchTerm.toLowerCase())\n  );\n\n  const handleSelect = (taskId) => {\n    onSelect(taskId, selectedEmployee);\n  };\n\n  const handleKeyDown = (e) => {\n    if (e.key === 'Escape') {\n      onCancel();\n    } else if (e.key === 'Enter' && filteredTasks.length > 0) {\n      handleSelect(filteredTasks[0].id);\n    }\n  };\n\n  const handleBlur = (e) => {\n    setTimeout(() => {\n      const activeElement = document.activeElement;\n      const dropdownElement = dropdownRef.current;\n      const portalElement = portalContainer;\n      \n      const focusInsideDropdown = (\n        (dropdownElement && dropdownElement.contains(activeElement)) ||\n        (portalElement && portalElement.contains(activeElement)) ||\n        (activeElement && activeElement.closest('[data-dropdown-content]'))\n      );\n      \n      if (!focusInsideDropdown) {\n        console.log(\"🔍 Fokus verlassen - schließe Dropdown\");\n        onCancel();\n      }\n    }, 100);\n  };\n\n  const dropdownStyle = {\n    position: 'fixed',\n    top: `${dropdownPosition.top}px`,\n    left: `${dropdownPosition.left}px`,\n    width: `${dropdownPosition.width}px`,\n    maxHeight: `${dropdownPosition.maxHeight}px`\n  };\n\n  const renderDropdown = () => (\n    <div \n      ref={dropdownRef}\n      className=\"dropdown-list\"\n      style={dropdownStyle}\n      data-dropdown-content=\"true\"\n    >\n      {loading && (\n        <div className=\"dropdown-loading\">\n          🔄 Prüfe Mitarbeiter-Verfügbarkeit...\n        </div>\n      )}\n\n      <div className=\"dropdown-header\">\n        🏢 Raum-Planung mit Mitarbeiter-Zuweisung\n      </div>\n\n      <div\n        onClick={() => handleSelect(\"\")}\n        className=\"dropdown-item remove-item\"\n      >\n        🗑️ Entfernen\n      </div>\n\n      <div className=\"employee-select-section\">\n        <label className=\"employee-select-label\">\n          👤 Mitarbeiter zuweisen:\n        </label>\n        <select\n          value={selectedEmployee}\n          onChange={(e) => {\n            console.log(\"🔍 Mitarbeiter geändert:\", e.target.value);\n            setSelectedEmployee(e.target.value);\n          }}\n          className=\"employee-select\"\n        >\n          <option value=\"\">-- Kein Mitarbeiter --</option>\n          {employees.map(emp => (\n            <option key={emp.id} value={emp.id}>\n              {emp.name}\n            </option>\n          ))}\n        </select>\n        {selectedEmployee && (\n          <div className=\"employee-success-msg\">\n            ✓ Verfügbarkeitsprüfung wird durchgeführt\n          </div>\n        )}\n      </div>\n\n      {filteredTasks.map(task => (\n        <div\n          key={task.id}\n          onClick={() => handleSelect(task.id)}\n          className=\"dropdown-item\"\n          style={{\n            fontWeight: currentTask === task.name ? '600' : '500',\n            backgroundColor: currentTask === task.name ? '#f8f9fa' : 'white'\n          }}\n        >\n          <div\n            className=\"task-color-preview\"\n            style={{ backgroundColor: getModernTaskColor(task.name) }}\n          />\n          <span style={{ flex: 1 }}>{task.name}</span>\n          <span className=\"task-duration\">{task.duration_minutes}min</span>\n        </div>\n      ))}\n\n      {filteredTasks.length === 0 && searchTerm && (\n        <div style={{\n          padding: '10px 12px',\n          color: '#868e96',\n          fontSize: '13px',\n          fontStyle: 'italic'\n        }}>\n          Keine Tasks gefunden\n        </div>\n      )}\n    </div>\n  );\n\n  return (\n    <div className=\"search-dropdown\">\n      <input\n        ref={inputRef}\n        type=\"text\"\n        className=\"search-input\"\n        placeholder={loading ? \"Prüfe Verfügbarkeit...\" : \"Task für Raum suchen...\"}\n        value={searchTerm}\n        onChange={(e) => setSearchTerm(e.target.value)}\n        onKeyDown={handleKeyDown}\n        onBlur={handleBlur}\n        disabled={loading}\n      />\n      \n      {portalContainer && ReactDOM.createPortal(renderDropdown(), portalContainer)}\n    </div>\n  );\n}\n\n// ─── HAUPTKOMPONENTE ───\nfunction App(props) {\n  // State\n  const roomId = appsmith.model?.selectedRoom ?? null;\n  const roomName = appsmith.model?.selectedRoomName ?? null;\n  const tasks = appsmith.model?.tasks || [];\n  const employees = appsmith.model?.employees || [];\n\n  const [allGridStates, setAllGridStates] = React.useState({});\n  const [activeCell, setActiveCell] = React.useState(null);\n  const [dragSource, setDragSource] = React.useState(null);\n  const [debugLog, setDebugLog] = React.useState([]);\n\n  // Debug-Funktion\n  const addDebugLog = React.useCallback((message) => {\n    console.log(\"DEBUG:\", message);\n    setDebugLog(prev => [...prev.slice(-4), `${new Date().toLocaleTimeString()}: ${message}`]);\n  }, []);\n\n  // Lade Raum-Schedule\n  React.useEffect(() => {\n    if (!roomId) {\n      setAllGridStates({});\n      return;\n    }\n\n    const rawData = appsmith.model.initialData || [];\n    const loaded = {};\n    \n    if (Array.isArray(rawData)) {\n      addDebugLog(`Transformiere ${rawData.length} DB-Records zu Widget-Format`);\n      \n      rawData.forEach(record => {\n        const {\n          schedule_id,\n          day_abbrev,\n          start_time,\n          end_time,\n          task_name,\n          duration_minutes,\n          employee_id\n        } = record;\n        \n        const startTime = start_time.slice(0, 5);\n        const key = `${day_abbrev}-${startTime}`;\n        const rowspan = Math.ceil(duration_minutes / 15);\n        \n        loaded[key] = {\n          task: task_name,\n          taskId: record.task_id,\n          root: true,\n          rowspan: rowspan,\n          existing: true,\n          scheduleId: schedule_id,\n          assignedEmployee: employee_id,\n          duration_minutes: duration_minutes\n        };\n        \n        // Fülle weitere Zellen für rowspan\n        const slots = generateTimeSlots();\n        const startIdx = slots.indexOf(startTime);\n        for (let i = 1; i < rowspan; i++) {\n          const nextTime = slots[startIdx + i];\n          if (nextTime) {\n            loaded[`${day_abbrev}-${nextTime}`] = {\n              task: task_name,\n              taskId: record.task_id,\n              root: false,\n              rowspan: rowspan,\n              existing: true,\n              scheduleId: schedule_id,\n              assignedEmployee: employee_id,\n              duration_minutes: duration_minutes\n            };\n          }\n        }\n      });\n      \n      addDebugLog(`✓ Transformiert zu Widget-Keys: [${Object.keys(loaded).join(', ')}]`);\n    }\n    \n    setAllGridStates(prev => {\n      const copy = { ...prev };\n      const currentState = copy[roomId] || {};\n      const hasUnsavedLocal = hasUnsavedChanges(currentState);\n      \n      addDebugLog(`RaumID: ${roomId}, hasUnsavedLocal: ${hasUnsavedLocal}`);\n      \n      if (!hasUnsavedLocal) {\n        addDebugLog(`✓ Übernehme transformierte DB-Daten für Raum ${roomId} (${Object.keys(loaded).length} Zellen)`);\n        copy[roomId] = loaded;\n        return copy;\n      }\n      \n      addDebugLog(`⚠️ Behalte lokale Änderungen für Raum ${roomId} (${Object.keys(currentState).length} Einträge)`);\n      return prev;\n    });\n  }, [roomId, JSON.stringify(appsmith.model.initialData || []), addDebugLog]);\n\n  const gridState = allGridStates[roomId] || {};\n  const hasChanges = hasUnsavedChanges(gridState);\n\n  // ─── VERFÜGBARKEITSPRÜFUNG ───\n  const checkEmployeeAvailability = async (employeeId, day, time, durationMinutes) => {\n    if (!employeeId) {\n      addDebugLog(\"❌ Kein Mitarbeiter ausgewählt - überspringe Verfügbarkeitsprüfung\");\n      return { available: true, conflicts: [] };\n    }\n    \n    addDebugLog(`🔍 Prüfe Verfügbarkeit für Mitarbeiter ${employeeId} am ${day} ${time} (${durationMinutes}min)`);\n    \n    try {\n      const endTime = calculateEndTime(time, durationMinutes);\n      addDebugLog(`Verfügbarkeitsprüfung: ${day} ${time}-${endTime} für Mitarbeiter ${employeeId}`);\n      \n      const requestId = `check_${employeeId}_${day}_${time}_${Date.now()}`;\n      \n      // Store initialisieren\n      appsmith.store.availabilityConflicts = [];\n      appsmith.store.availabilityRequestId = null;\n      \n      // Model aktualisieren\n      appsmith.updateModel({\n        checkAvailability: {\n          employeeId: parseInt(employeeId, 10),\n          dayAbbrev: day,\n          startTime: time,\n          endTime: endTime,\n          requestId: requestId\n        }\n      });\n      \n      addDebugLog(`Model aktualisiert mit RequestID: ${requestId}`);\n      \n      // Event auslösen\n      await appsmith.triggerEvent(\"onCheckAvailability\");\n      addDebugLog(\"Event ausgelöst, warte auf Ergebnis...\");\n      \n      // Polling für Ergebnis\n      let attempts = 0;\n      \n      while (attempts < CONFIG.maxPollingAttempts) {\n        await new Promise(resolve => setTimeout(resolve, CONFIG.pollingInterval));\n        attempts++;\n        \n        const currentRequestId = appsmith.store?.availabilityRequestId;\n        const conflicts = appsmith.store?.availabilityConflicts;\n        \n        if (currentRequestId === requestId && Array.isArray(conflicts)) {\n          addDebugLog(`✅ Verfügbarkeitsprüfung abgeschlossen nach ${attempts * CONFIG.pollingInterval}ms: ${conflicts.length} Konflikte`);\n          \n          return {\n            available: conflicts.length === 0,\n            conflicts: conflicts\n          };\n        }\n        \n        addDebugLog(`Polling Attempt ${attempts}/${CONFIG.maxPollingAttempts} - RequestID: ${currentRequestId}, Conflicts: ${conflicts?.length || 'undefined'}`);\n      }\n      \n      // Timeout erreicht\n      addDebugLog(`⚠️ Verfügbarkeitsprüfung Timeout nach ${CONFIG.maxPollingAttempts * CONFIG.pollingInterval}ms - verwende Fallback`);\n      return { available: true, conflicts: [] };\n      \n    } catch (error) {\n      addDebugLog(`Verfügbarkeitsprüfung fehlgeschlagen: ${error.message} - Task wird trotzdem erstellt`);\n      return { available: true, conflicts: [] };\n    }\n  };\n\n  // ─── TASK SELECTION ───\n  const handleTaskSelect = async (selectedTaskId, assignedEmployeeId, cellDay, cellTime) => {\n    addDebugLog(`🎯 Task Selection: ${selectedTaskId}, Employee: ${assignedEmployeeId}, Position: ${cellDay}-${cellTime}`);\n    \n    if (!roomId || !cellDay || !cellTime) {\n      addDebugLog(\"❌ Abbruch: Fehlende Parameter\");\n      setActiveCell(null);\n      return;\n    }\n\n    const key = `${cellDay}-${cellTime}`;\n    const cellData = gridState[key] || null;\n\n    // Entfernen\n    if (selectedTaskId === \"\") {\n      addDebugLog(\"🗑️ Task entfernen gewählt\");\n      if (cellData?.root) {\n        if (cellData.existing && cellData.scheduleId) {\n          appsmith.updateModel({ scheduleIdToDelete: cellData.scheduleId });\n          appsmith.triggerEvent(\"onDeleteSingle\");\n        }\n        removeBlockLocal(cellDay, cellTime);\n      }\n      setActiveCell(null);\n      return;\n    }\n\n    // Task finden\n    const taskObj = tasks.find(t => t.id === parseInt(selectedTaskId, 10));\n    if (!taskObj) {\n      addDebugLog(`❌ Task nicht gefunden: ${selectedTaskId}`);\n      setActiveCell(null);\n      return;\n    }\n\n    addDebugLog(`✅ Task gefunden: ${taskObj.name} (${taskObj.duration_minutes}min)`);\n\n    // Verfügbarkeitsprüfung\n    if (assignedEmployeeId) {\n      addDebugLog(\"🔍 STARTE VERFÜGBARKEITSPRÜFUNG\");\n      \n      try {\n        // Loading-Anzeige\n        const originalActiveCell = activeCell;\n        setActiveCell({ \n          ...originalActiveCell, \n          loading: true \n        });\n        \n        const availability = await checkEmployeeAvailability(\n          assignedEmployeeId, \n          cellDay, \n          cellTime, \n          taskObj.duration_minutes\n        );\n        \n        // Loading entfernen\n        setActiveCell(originalActiveCell);\n        \n        if (!availability.available && availability.conflicts.length > 0) {\n          const employeeName = employees.find(e => e.id == assignedEmployeeId)?.name || `Mitarbeiter ${assignedEmployeeId}`;\n          \n          const conflictMsg = availability.conflicts.map(c => {\n            return `${c.start_time.slice(0,5)}-${c.end_time.slice(0,5)}: ${c.task_name}${c.room_name ? ` (${c.room_name})` : ''}`;\n          }).join('\\n');\n          \n          const confirmed = window.confirm(\n            `⚠️ MITARBEITER-KONFLIKT!\\n\\n${employeeName} ist bereits verplant:\\n\\n${conflictMsg}\\n\\nTrotzdem den Termin erstellen/ändern?`\n          );\n          \n          if (!confirmed) {\n            addDebugLog(\"❌ Task-Erstellung vom User abgebrochen wegen Konflikt\");\n            setActiveCell(null);\n            return;\n          } else {\n            addDebugLog(\"✅ User bestätigt Erstellung trotz Konflikt\");\n          }\n        } else {\n          addDebugLog(`✅ Mitarbeiter ist verfügbar - keine Konflikte gefunden`);\n        }\n        \n      } catch (error) {\n        addDebugLog(`❌ Verfügbarkeitsprüfung Fehler: ${error.message} - erstelle Task trotzdem`);\n        setActiveCell(activeCell);\n      }\n    } else {\n      addDebugLog(\"ℹ️ Kein Mitarbeiter ausgewählt - überspringe Verfügbarkeitsprüfung\");\n    }\n\n    // Task erstellen/updaten\n    try {\n      if (cellData?.root && cellData.existing) {\n        addDebugLog(\"🔄 Update existierenden Task\");\n        \n        updateSingleTask({\n          scheduleId: cellData.scheduleId,\n          newTaskId: parseInt(selectedTaskId, 10),\n          newDay: cellDay,\n          newTime: cellTime,\n          assignedEmployee: assignedEmployeeId\n        });\n        \n        updateBlockInGrid(taskObj, cellDay, cellTime, assignedEmployeeId, cellData.scheduleId, true);\n      } else {\n        addDebugLog(\"🆕 Erstelle neuen Task\");\n        if (cellData?.root && !cellData.existing) {\n          removeBlockLocal(cellDay, cellTime);\n        }\n        \n        createNewBlock(taskObj, cellDay, cellTime, assignedEmployeeId);\n        addDebugLog(`✅ Neuer Block erstellt für Task: ${taskObj.name}`);\n      }\n    } catch (error) {\n      addDebugLog(`❌ Fehler beim Task erstellen: ${error.message}`);\n    }\n    \n    setActiveCell(null);\n  };\n\n  // ─── BLOCK MANAGEMENT ───\n  const removeBlockLocal = (day, time) => {\n    addDebugLog(`🗑️ Entferne Block: ${day}-${time}`);\n    setAllGridStates(prev => {\n      const copy = { ...prev };\n      const current = { ...(copy[roomId] || {}) };\n      const key = `${day}-${time}`;\n      const cellData = current[key];\n      \n      if (cellData?.root) {\n        const rowspan = cellData.rowspan || 1;\n        const slots = generateTimeSlots();\n        const startIdx = slots.indexOf(time);\n        \n        for (let i = 0; i < rowspan; i++) {\n          const t = slots[startIdx + i];\n          if (!t) break;\n          delete current[`${day}-${t}`];\n        }\n      }\n      \n      copy[roomId] = current;\n      return copy;\n    });\n  };\n\n  const createNewBlock = (taskObj, day, time, assignedEmployeeId = null) => {\n    addDebugLog(`🆕 Erstelle neuen Block: ${taskObj.name} bei ${day}-${time}`);\n    const slots = generateTimeSlots();\n    const startIdx = slots.indexOf(time);\n    const durationSlots = Math.ceil(taskObj.duration_minutes / CONFIG.slotMinutes);\n    \n    setAllGridStates(prev => {\n      const copy = { ...prev };\n      const current = { ...(copy[roomId] || {}) };\n      \n      for (let i = 0; i < durationSlots; i++) {\n        const t = slots[startIdx + i];\n        if (!t) break;\n        \n        current[`${day}-${t}`] = {\n          task: taskObj.name,\n          taskId: taskObj.id,\n          root: i === 0,\n          rowspan: durationSlots,\n          existing: false,\n          scheduleId: null,\n          assignedEmployee: assignedEmployeeId,\n          duration_minutes: taskObj.duration_minutes\n        };\n      }\n      \n      copy[roomId] = current;\n      addDebugLog(`✅ Block erstellt: ${Object.keys(current).length} Zellen im Grid`);\n      return copy;\n    });\n  };\n\n  const updateBlockInGrid = (taskObj, day, time, assignedEmployeeId, scheduleId, existing) => {\n    const slots = generateTimeSlots();\n    const startIdx = slots.indexOf(time);\n    const durationSlots = Math.ceil(taskObj.duration_minutes / CONFIG.slotMinutes);\n    \n    setAllGridStates(prev => {\n      const copy = { ...prev };\n      const current = { ...(copy[roomId] || {}) };\n      \n      // Entferne alte Zellen mit derselben scheduleId\n      Object.keys(current).forEach(key => {\n        if (current[key]?.scheduleId === scheduleId) {\n          delete current[key];\n        }\n      });\n      \n      // Erstelle neue Zellen\n      for (let i = 0; i < durationSlots; i++) {\n        const t = slots[startIdx + i];\n        if (!t) break;\n        \n        current[`${day}-${t}`] = {\n          task: taskObj.name,\n          taskId: taskObj.id,\n          root: i === 0,\n          rowspan: durationSlots,\n          existing: existing,\n          scheduleId: scheduleId,\n          assignedEmployee: assignedEmployeeId,\n          duration_minutes: taskObj.duration_minutes\n        };\n      }\n      \n      copy[roomId] = current;\n      return copy;\n    });\n  };\n\n  // ─── EVENT HANDLERS ───\n  const updateSingleTask = ({ scheduleId, newTaskId, newDay, newTime, assignedEmployee }) => {\n    addDebugLog(`🔄 updateSingleTask: scheduleId=${scheduleId}, taskId=${newTaskId}, employee=${assignedEmployee}`);\n    \n    appsmith.updateModel({\n      updateSingleData: {\n        scheduleId,\n        newTaskId,\n        newDay,\n        newTime,\n        assignedEmployee,\n        roomId\n      }\n    });\n    \n    appsmith.triggerEvent(\"onUpdateSingle\");\n  };\n\n  const deleteSingleTask = scheduleId => {\n    if (!scheduleId || !roomId) return;\n    addDebugLog(`🗑️ Lösche Task mit scheduleId: ${scheduleId}`);\n    appsmith.updateModel({ scheduleIdToDelete: scheduleId });\n    appsmith.triggerEvent(\"onDeleteSingle\");\n    \n    setAllGridStates(prev => {\n      const copy = { ...prev };\n      const current = { ...(copy[roomId] || {}) };\n      const rootKey = Object.keys(current).find(\n        key => current[key]?.scheduleId === scheduleId && current[key]?.root\n      );\n      if (rootKey) {\n        const [day, time] = rootKey.split(\"-\");\n        removeBlockLocal(day, time);\n      }\n      copy[roomId] = current;\n      return copy;\n    });\n    setActiveCell(null);\n  };\n\n  const saveRoom = () => {\n    if (!roomId) return;\n    \n    const newEntries = {};\n    Object.entries(gridState).forEach(([key, cellData]) => {\n      if (!cellData.root) return;\n      if (cellData.existing) return;\n      newEntries[key] = cellData;\n    });\n    \n    addDebugLog(`💾 Speichere ${Object.keys(newEntries).length} neue Einträge`);\n    \n    if (Object.keys(newEntries).length === 0) {\n      addDebugLog(\"ℹ️ Keine neuen Einträge zum Speichern\");\n      window.alert(\"Keine neuen Termine zum Speichern vorhanden.\");\n      return;\n    }\n    \n    const payload = {\n      roomId,\n      gridState: JSON.parse(JSON.stringify(newEntries)),\n      fullGridState: JSON.parse(JSON.stringify(gridState))\n    };\n    \n    appsmith.updateModel({ lastSaveData: payload });\n    \n    try {\n      appsmith.triggerEvent(\"onSaveRoom\");\n      addDebugLog(\"✅ Event erfolgreich ausgelöst\");\n      \n      setAllGridStates(prev => {\n        const copy = { ...prev };\n        const current = { ...(copy[roomId] || {}) };\n        \n        Object.keys(newEntries).forEach(key => {\n          if (current[key]) {\n            current[key] = {\n              ...current[key],\n              existing: true\n            };\n          }\n        });\n        \n        copy[roomId] = current;\n        return copy;\n      });\n      \n    } catch (error) {\n      addDebugLog(`❌ Event-Fehler: ${error.message}`);\n    }\n  };\n\n  const resetRoom = () => {\n    if (!roomId) return;\n    addDebugLog(\"🔄 Raum zurücksetzen - nur lokale ungespeicherte Änderungen\");\n    \n    setAllGridStates(prev => {\n      const copy = { ...prev };\n      const current = { ...(copy[roomId] || {}) };\n      \n      let removedCount = 0;\n      const keysToRemove = [];\n      \n      Object.entries(current).forEach(([key, cellData]) => {\n        if (cellData && !cellData.existing) {\n          keysToRemove.push(key);\n          if (cellData.root) removedCount++;\n        }\n      });\n      \n      keysToRemove.forEach(key => {\n        delete current[key];\n      });\n      \n      addDebugLog(`✅ ${removedCount} ungespeicherte Tasks entfernt, DB-Tasks bleiben erhalten`);\n      \n      copy[roomId] = current;\n      return copy;\n    });\n  };\n\n  const deleteRoomData = async () => {\n    if (!roomId) {\n      window.alert(\"Bitte zuerst einen Raum auswählen.\");\n      return;\n    }\n    addDebugLog(\"🗑️ Alle Raum-Daten löschen\");\n    appsmith.updateModel({ initialData: {} });\n    appsmith.triggerEvent(\"onDeleteAllRoom\");\n    setAllGridStates(prev => {\n      const copy = { ...prev };\n      copy[roomId] = {};\n      return copy;\n    });\n    setActiveCell(null);\n  };\n\n  const prepareTableData = () => {\n    if (!roomId) return [];\n    \n    const currentGrid = allGridStates[roomId] || {};\n    const timeSlots = generateTimeSlots();\n    const tableData = [];\n    \n    tableData.push({\n      Zeit: `RAUM: ${roomName || `Raum ${roomId}`} (ID: ${roomId})`,\n      Mo: \"\", Di: \"\", Mi: \"\", Do: \"\", Fr: \"\"\n    });\n\n    tableData.push({ Zeit: \"\", Mo: \"\", Di: \"\", Mi: \"\", Do: \"\", Fr: \"\" });\n\n    tableData.push({\n      Zeit: \"ZEIT\", Mo: \"MONTAG\", Di: \"DIENSTAG\", \n      Mi: \"MITTWOCH\", Do: \"DONNERSTAG\", Fr: \"FREITAG\"\n    });\n    \n    for (let time of timeSlots) {\n      const row = { Zeit: time };\n      for (let day of CONFIG.days) {\n        const key = `${day}-${time}`;\n        const cell = currentGrid[key];\n        if (cell && cell.root) {\n          let cellContent = cell.task;\n          if (cell.assignedEmployee) {\n            const emp = employees.find(e => e.id == cell.assignedEmployee);\n            const empName = emp?.name || `MA${cell.assignedEmployee}`;\n            cellContent += ` [${empName}]`;\n          }\n          row[day] = cellContent;\n        } else {\n          row[day] = \"\";\n        }\n      }\n      tableData.push(row);\n    }\n    \n    return tableData;\n  };\n\n  React.useEffect(() => {\n    const tableData = prepareTableData();\n    const entityName = roomName || `Raum_${roomId}`;\n    const cleanName = entityName.replace(/[^a-zA-Z0-9äöüÄÖÜß]/g, '_');\n    \n    appsmith.updateModel({ \n      tableData: tableData,\n      hasTableData: tableData.length > 0,\n      roomId: roomId,\n      exportFileName: `Raumplan_${cleanName}_${roomId}_${new Date().toISOString().split('T')[0]}`,\n      currentRoomName: entityName\n    });\n  }, [allGridStates, roomId, roomName]);\n\n  const openExportModal = () => {\n    if (!roomId) {\n      window.alert(\"Bitte zuerst einen Raum auswählen, um zu exportieren.\");\n      return;\n    }\n    \n    const tableData = prepareTableData();\n    if (tableData.length <= 3) {\n      window.alert(\"Raum-Grid ist leer. Nichts zum Exportieren.\");\n      return;\n    }\n    \n    appsmith.updateModel({ \n      tableData: tableData,\n      exportFileName: `Raumplan_${roomName}_${roomId}_${new Date().toISOString().split('T')[0]}`,\n      currentRoomName: roomName\n    });\n    \n    appsmith.triggerEvent(\"onOpenExportModal\");\n  };\n\n  const onDragStart = (e, day, time) => {\n    e.dataTransfer.setData(\"text/plain\", JSON.stringify({ day, time }));\n    setDragSource({ day, time });\n  };\n\n  const onDragOver = e => e.preventDefault();\n\n  const onDrop = (e, targetDay, targetTime) => {\n    e.preventDefault();\n    setDragSource(null);\n  };\n\n  // ─── MEMOIZED CALCULATIONS ───\n  const skipCells = React.useMemo(() => {\n    const result = {};\n    const timeSlots = generateTimeSlots();\n    Object.entries(gridState).forEach(([key, cellData]) => {\n      if (cellData.root) {\n        const [day, time] = key.split(\"-\");\n        const idx = timeSlots.indexOf(time);\n        for (let i = 1; i < cellData.rowspan; i++) {\n          const next = timeSlots[idx + i];\n          if (next) {\n            result[`${day}-${next}`] = true;\n          }\n        }\n      }\n    });\n    return result;\n  }, [gridState]);\n\n  const handleCellClick = React.useCallback((day, time) => {\n    if (!roomId) {\n      window.alert(\"Bitte zuerst einen Raum auswählen.\");\n      return;\n    }\n    addDebugLog(`🎯 Zelle ${day}-${time} angeklickt`);\n    setActiveCell({ day, time });\n  }, [roomId, addDebugLog]);\n\n  // ─── RENDER GRID ───\n  const renderGrid = () => {\n    const timeSlots = generateTimeSlots();\n\n    return (\n      <div className=\"widget-container\">\n        {/* Header */}\n        <div className=\"room-header\">\n          <h3>🏢 Raumplanung - Verfügbarkeitsprüfung</h3>\n          <div className=\"room-info\">\n            <strong>Aktueller Raum:</strong> {roomName || 'Kein Raum ausgewählt'} \n            {roomId && ` (ID: ${roomId})`}\n          </div>\n          <div className=\"room-details\">\n            🔍 Automatische Verfügbarkeitsprüfung bei Mitarbeiter-Zuweisung\n          </div>\n          <div className=\"room-details\">\n            📊 Grid-Status: {Object.keys(gridState).length} Zellen aktiv\n          </div>\n        </div>\n\n        {/* Ungespeicherte Änderungen */}\n        {hasChanges && (\n          <div className=\"unsaved-warning\">\n            <span>⚠️</span>\n            <span>Du hast ungespeicherte Änderungen!</span>\n          </div>\n        )}\n\n        {/* Button-Zeile */}\n        <div className=\"button-row\">\n          <button className=\"modern-btn btn-reset\" onClick={resetRoom}>\n            <span>🔄</span>\n            Zurücksetzen (Raum)\n          </button>\n          <button className=\"modern-btn btn-delete-all\" onClick={deleteRoomData}>\n            <span>🗑️</span>\n            Alle Termine löschen\n          </button>\n          <button className=\"modern-btn btn-save\" onClick={saveRoom}>\n            <span>💾</span>\n            Speichern {hasChanges && '(!)'}\n          </button>\n          <button className=\"modern-btn btn-export\" onClick={openExportModal}>\n            <span>📊</span>\n            Excel/CSV Export\n          </button>\n        </div>\n\n        <table className=\"grid-table\">\n          <thead>\n            <tr>\n              <th className=\"time-cell\">⏰ Zeit</th>\n              {CONFIG.days.map(day => (\n                <th key={day} className=\"day-cell\">\n                  📅 {day}\n                </th>\n              ))}\n            </tr>\n          </thead>\n          <tbody>\n            {timeSlots.map((time, rowIdx) => (\n              <tr key={time}>\n                <td className=\"time-cell\">{time}</td>\n                {CONFIG.days.map(day => {\n                  const key = `${day}-${time}`;\n                  if (skipCells[key]) return null;\n\n                  const cellData = gridState[key];\n                  const isActive = activeCell?.day === day && activeCell?.time === time;\n\n                  // Task-Zelle\n                  if (cellData?.root) {\n                    return (\n                      <td\n                        key={key}\n                        rowSpan={cellData.rowspan}\n                        className=\"task-cell\"\n                        style={{ backgroundColor: getModernTaskColor(cellData.task) }}\n                        draggable=\"true\"\n                        onDragStart={e => onDragStart(e, day, time)}\n                        onDragOver={onDragOver}\n                      >\n                        {/* Ungespeicherte Änderung Badge */}\n                        {!cellData.existing && (\n                          <div className=\"unsaved-badge\"></div>\n                        )}\n\n                        <div className=\"task-content\">\n                          {/* Dropdown oder Task-Anzeige */}\n                          {isActive ? (\n                            <RoomPlanningDropdown\n                              tasks={tasks}\n                              employees={employees}\n                              currentTask={cellData.task}\n                              currentEmployee={cellData.assignedEmployee}\n                              onSelect={(taskId, employeeId) => handleTaskSelect(taskId, employeeId, day, time)}\n                              onCancel={() => setActiveCell(null)}\n                              isInTableCell={true}\n                              loading={activeCell?.loading || false}\n                            />\n                          ) : (\n                            <div style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>\n                              <span\n                                className=\"task-name\"\n                                onClick={() => handleCellClick(day, time)}\n                                style={{ color: '#333' }}\n                              >\n                                {cellData.task}\n                              </span>\n                              {cellData.assignedEmployee && (\n                                <div className=\"task-employee-badge\">\n                                  👤 {employees.find(e => e.id == cellData.assignedEmployee)?.name || `MA${cellData.assignedEmployee}`}\n                                </div>\n                              )}\n                            </div>\n                          )}\n\n                          {/* Lösch-Button */}\n                          {cellData.existing && cellData.scheduleId && (\n                            <button\n                              className=\"delete-icon\"\n                              onClick={() => deleteSingleTask(cellData.scheduleId)}\n                              title=\"Diesen Task löschen\"\n                            >\n                              🗑️\n                            </button>\n                          )}\n                        </div>\n                      </td>\n                    );\n                  }\n\n                  // Freie Zelle\n                  return (\n                    <td\n                      key={key}\n                      className=\"empty-cell\"\n                      onClick={() => handleCellClick(day, time)}\n                      onDragOver={onDragOver}\n                      onDrop={e => onDrop(e, day, time)}\n                    >\n                      {isActive ? (\n                        <RoomPlanningDropdown\n                          tasks={tasks}\n                          employees={employees}\n                          onSelect={(taskId, employeeId) => handleTaskSelect(taskId, employeeId, day, time)}\n                          onCancel={() => setActiveCell(null)}\n                          isInTableCell={true}\n                          loading={activeCell?.loading || false}\n                        />\n                      ) : null}\n                    </td>\n                  );\n                })}\n              </tr>\n            ))}\n          </tbody>\n        </table>\n      </div>\n    );\n  };\n\n  return renderGrid();\n}\n\nfunction render() {\n  ReactDOM.render(<App />, document.getElementById(\"root\"));\n}\n\nappsmith.onReady(() => {\n  render();\n});\n\nappsmith.onModelChange(() => {\n  render();\n});"
  },
  "version": 1,
  "widgetId": "xzcfw9uwdb",
  "widgetName": "RoomPlanningWidget"
}